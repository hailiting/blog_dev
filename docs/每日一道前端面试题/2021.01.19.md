# 对闭包的看法，为什么要使用闭包，说一下闭包原理以及应用场景

## 今日解题

### 什么是闭包

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成闭包。
可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因为闭包会把函数中的变量值存储到内存中，会 对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄露。当不需要使用闭包时，要及时释放内存，可将内存函数对象的变量赋值为 Null.

### 闭包原理

函数执行分为两个阶段

- 预编译
  - 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在闭包，则只需要增加对应属性值即可。
- 执行
  - 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持有改“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量。

利用函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。

### 优点

- 1. 可以从内部函数访问外部函数的作用域中的变量，且访问的变量长期驻扎在内存中，可供之后使用
- 2. 避免变量污染全局
- 3. 把变量存到独立的作用域，作为私有成员存在

### 缺点

- 1. 对内存销毁有负面影响。因为内部函数保存的外部变量引用，所以无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄露。
- 2. 对处理速度具有负面影响。闭包的层级决定了引用外部变量在查找时经过的作用域链的长度
- 3. 可能获取到意外的值（captured value）

### 应用场景

- 典型的应用是模块封装，在各模块规范出现之前，都是使用闭包防止变量污染全局

```js
var abc = (function () {
  var foo = 0;
  function abc() {}
  abc.prototype.bar = function bar() {
    return foo;
  };
  return abc;
})();
```

- 在循环中创建闭包，防止取到意外的值

```js
/// 获得意外的值
for (var i = 0; i < 3; i++) {
  document.getElementById("id" + i).onfocus = function () {
    alert(i); /// i一直是3
  };
}
/// 使用闭包，圈住作用域
function makeCallback(num) {
  return function () {
    alert(num);
  };
}
for (var i = 0; i < 3; i++) {
  document.getElementById("id" + i).onfocus = makeCallback(i);
}
```
