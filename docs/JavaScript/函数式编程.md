# 函数式编程

## 函数式编程的思维

- 函数式编程的一个明显好处是：声明式代码，对于无副作用的纯函数，完全可以不考虑函数内部是如何实现的，专注于编写业务代码，优化代码时，只需集中在这些稳定坚固的纯函数内部即可
- 对于不纯函数，代码会产生副作用或对外部环境过于依赖，使用他们的时候，总要考虑这些不干净的副作用。系统越大，出现问题的可能就越大

### 范畴

- 1. 函数式编程是范畴论的数学分支，他认为世界上所有概念体系都可以抽象出一个个范畴
- 2. 彼此之间存在某种关系概念、事务、对象等等，都构成范畴，任何事物只要找出他们之间的关系，就能定义
- 3. 箭头表示范畴成员之间的关系，正式的名称叫做“态射”（morphism），范畴论认为，同一范畴的所有成员，就是不同状态的"变形"（transformation）。通过“态射”，一个成员可以变形成另一个成员
- 4. 所有的成员是一个集合
- 5. 变形关系是函数

### 基本概念

- 1. 函数式编程(Functional Programming)在计算机诞生前就已经存在了，其基础模型来自`λ(lambda x=>x*2)`演算，而 λ 演算并不是设计于计算机上执行，它是在 20 世纪三十年代引入的一套用于研究函数定义、函数应用和递归的形式系统
- 2. 函数式编程的主旨是：将复杂的函数拆分成简单的函数(计算理论，或者递归论、或 lambda 演算)。运算过程尽量写成一系列嵌套的函数调用
- 3. 高阶函数是函数式编程的一小部分

### 特点

- 1. 函数是一等公民，可以 赋值给其他变量，也可以作为参数，传入另一个函数，或作为别的函数的返回值
- 2. 不可改变量。在函数式编程中，变量仅仅代表某个表达式，这里的变量是不能被修改的，而所有的变量只能被赋值一次初始值
- 3. map, reduce 是最常用的函数式编程方法
- 4. 只用表达式，不用语句
- 5. 没有副作用
- 6. 不能修改状态
- 7. 引用透明（函数运行只能靠参数）

## 函数式编程常用核心概念

### 纯函数

- 相同的输入，永远得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态
- 优点：减低系统的复杂度，可缓存
- 缺点：扩展性差，可以用柯里化解决

```js
var xs = [1, 2, 3, 4, 5, 6, 7];
// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的
xs.slice(0, 3);
xs.slice(0, 3);
xs.splice(0, 3);
xs.splice(0, 3);
```

### 函数的柯里化

传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

- 避免纯函数的值对外界产生依赖
- 柯里化是一种"预加载"函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的”缓存“，是一种高效的编写函数的方法

```js
var checkage = (min) => (age) => age > min;
var checkage18 = checkage(18);
checkage18(20);

function foo(p1, p2) {
  this.val = p1 + p2;
}
// 对参数进行缓存
// 闭包
var bar = foo.bind(null, "p1");
// new的优先级比bind高
var baz = new bar("p2");
console.log(baz.val);
```

```js
// lodash数组
import { curry } from "lodash";
var match = curry((reg, str) => str.match(reg));
var filter = curry((f, arr) => arr.filter(f));
var haveSpace = match(/\s+/g);
filter(haveSpace)(["sssa", "da asdad  assdf"]);
// 对某个值进行缓存
import _ from "lodash";
var sin = _.memorize((x) => Math.sin(x));
// 第一次要记忆，所以会慢一点
var a = sin(1);
// 第二次有了记忆，所以速度极快
var b = sin(1);
```

### 函数组合

为了解决柯里化函数嵌套的问题，所以函数组合

```js
const compose = (f, g) => (x) => f(g(x));
var first = (arr) => arr[0];
var reverse = (arr) => arr.reverse();
var last = compose(first, reverse);
last([1, 2, 3, 4]);
```

### Point free

- 把一些对象自带的方法转换为纯函数，不要命名转瞬即逝的中间变量
- 这个函数中，我们使用 str 作为中间变量，但这个中间变量除了让代码变长，其他毫无意义
- 减少一些不必要的命名，让代码保持简洁和通用

```js
const f = (str) => str.toUpperCase().split("");
// 改造
const compose = (f, g) => (x) => f(g(x));
const toUpperCase = (word) => word.toUpperCase();
const split = (x) => (str) => str.split(x);
const f = compose(split(" "), toUpperCase);
f("sada  asdfas sad");
```

### 声明式与命令式代码

- 命令式代码：编写一条又一条指令去让计算机执行一些动作，其中包含了很多复杂的细节
- 声明式代码：通过写表达式的方式来声明我们想干什么，与命令式比，代码可以组合，更加灵活

```js
// 命令式
let ceos = [];
for (var i = 0; i < companies.length; i++) {
  ceos.push(companies[i].ceo);
}
// 声明式
// 可以组合，更加灵活
let ceos = companies.map((c) => c.ceo);
```

### 惰性求值

在指令式语言中，以下代码会按顺序执行，由于每个函数都有可能改动或依赖于外部的状态，因此必须按顺序执行

```js
function somewhatLongOperation1() {
  dosomewhatLongOperation2;
}

function ajax() {
  var xhr = null;
  if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
  } else {
    xhr = new ActiveXObject("Microsoft.XMLHTTP");
  }
  ajax = xhr;
}
```

### 高阶函数

函数当做参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象

```js
// 命令式
var add = function(a, b) {
  return a + b;
};
function math(func, array) {
  return func(array[0], array[1]);
}
math(add, [1, 2]);
```

### 尾调用优化

递归

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
```

### 闭包

### 容器、Functor

### 错误处理、Either、AP

### io

### Monad

## 当下函数式编程最热的库

## 函数式编程的实际应用场景

1，函数式编程 不能有 if else
2，范畴论 变形=》太摄 =》变为了一个范畴

-> 固定的输入一定是固定的输出
-> 缓存
-> 柯里化

```js
/// 柯里化之前
function add(x, y) {
  return x + y;
}
add(1, 2);
/// 柯里化之后
function addX(x) {
  return function(y) {
    return x + y;
  };
}
var add8 = addX(8); // 被缓存了
var x = add8(9);
```

```js
function foo(p1, p2) {
  this.val = p1 + p2;
}
var bar = foo.bind(null, "p1");
var baz = new bar("p2");
console.log(baz.val);
```
