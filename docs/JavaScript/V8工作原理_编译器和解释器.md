# V8 工作原理--编译器和解释器

- 了解 V8 的执行机制，有利于
  - Babel 语言转换器原理
  - ESLint
  - Vue 和 React 底层实现机制

## 编译器和解释器

按语言的执行流程，可以把语言划分为编译型语言和解释型语言

- 编译型语言**在程序执行之前，需要通过编译器编译**，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译。比如 C/C++, GO 等都是编译型语言
- 由解释型语言编写的程序：在**每次运行时都需要通过解释器对程序进行动态解释和执行**。比如 python, javascript

## 编译器和解释器翻译流程

**AST 是一个数据结构**

- 编译器
  - 源代码-(词法分析/语法分析)-AST-(词义分析)-**中间代码-(代码优化)-二进制文件-(直接执行)-**执行
- 解释器
  - 源代码-(词法分析/语法分析)-AST-(词义分析)-**字节码-(解释执行)-**执行

## V8 是如何执行一段 JavaScript

- 源代码-(词法分析/语法分析-执行上下文)-AST-(词义分析 Ignition 解释器)-字节码-[(逐行解释执行) 机器码]|[(TurboFan 编译执行) 机器码]
  - Babel 的工作原理是将 ES6 装换为 AST，然后在将 ES6 语法的 AST 转化为 ES5 语法的 AST,最后利用 ES5 的 AST 生成 JavaScript 原代码
    - ES6 源码 -> ES6 AST -> ES5 AST -> Javascript
  - ESLint -> 利用 AST 来检查代码规范化问题

## AST 生成过程

- 分词(tokenize): 词法分析,将源码拆成一个个 token, 即语法上不可再分、最小的单个字符或字符串
- 语法分析

有了 AST 后，V8 会生成该段代码的执行上下文

## 生成字节码

有了 AST 和执行上下文，Ignition 会根据 AST 生成字节码，并解释执行字节码。
早期的 V8 没有字节码，而是直接将 AST 转换为机器码。因为 V8 需要消耗大量内存来存放转换后的机器码，为了解决内存占用问题，从而引入字节码

- 所谓的字节码，是指编译过程中的中间代码，可以把字节码看成是机器码的抽象
- 字节码介于 AST 和机器码之间的一种代码。字节码需要通过解释器将其转换为机器码后才能执行
- 机器码所占用的空间远远超过字节码，所以使用字节码可以减少系统的内存使用

## 执行代码

- 如果有一段第一次执行的字节码，解释器 Ignition 会逐条执行
- 如果在执行过程性，发现有**热点代码 HotSpot**，比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，并把转换后的机器码保存起来，当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以，这就大大提升了代码的执行效率
- 这种字节码配合解释器和编译器技术称为**即时编译 JIT**

## 如何提高 JavaScript 的性能

- 提升单次脚本的执行速度，**避免 JavaScript 的长任务霸占主线程**，这样就可以使页面快速响应交互
- **避免大的内联脚本**，因为在解析 HTML 过程中，解析和编译也会占用主线程
- **减少 JavaScript 文件的容量**，因为更小的文件会提升下载速度，并且占用更低内存
