# 操作系统 通信机制

跨线程，跨进程，跨机器，跨网络，跨 IDC

## 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在相互等待的进程称为死锁进程

- 死锁的必要条件
  - 竞争资源
    - 等待请求的资源被释放
    - 自身占用资源不释放
  - 进程的调度不当

### 死锁的四个必要条件

- 互斥条件
  - 进程对资源的使用是排他性的使用
  - 某资源只能由一个进程使用，其他进程需要使用只能等待
- 请求保持条件
  - 进程至少保持一个资源，又提出新的资源请求
  - 新资源被占用，请求被阻塞
  - 被阻塞的进程不释放自己保存的资源
  - 如何摒弃
    - 系统规定进程运行之前，一次性申请所以所需资源
    - 进程在运行期间不会提出资源请求，从而摒弃请求保持条件
- 不可剥夺条件
  - 进程获得的资源在未完成使用前不能被剥夺
  - 获得的资源只能由进程自身释放
  - 如何摒弃
    - 当一个进程请求新的资源得不到满足时，必须释放占有的资源
    - 进程运行时占有的资源可以被释放，意味着可以被剥夺
- 环路等待条件
  - 发生死锁时，必然存在进程-资源环形链
  - 如何摒弃
    - 可用资源线性排序，申请必须按照需要递增申请
    - 线性申请不再形成环路，从而摒弃了环路等待条件

### 同步三大经典案例

生产者 消费者  
读者 写者  
哲学家进餐问题（临界资源）

- 临界资源
  - 临界资源指一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放共享资源才可重新竞争使用共享资源
- 原子性
  - 原子性是指一系列操作不可被中断的特性
  - 一系列操作要么全部执行完成，要么全部没有执行
  - 不存在部分执行部分未执行情况

## 锁的分类

- 乐观锁，悲观锁
  - 悲观锁每次操作都加锁、乐观锁默认不添加锁
  - 悲观锁适合写操作场景
  - 乐观锁适合读操作场景
- 无锁/偏向锁/轻量级锁/重量级锁
  - 无锁：不锁资源，多个线程只一个线程修改成功，其他线程会重试
  - 偏向锁：同一个线程执行临界资源会自动获取资源
  - 轻量级锁：多个线程竞争同步资源时，没有获得资源的线程自旋等待释放
  - 重量级锁：多个线程竞争同步资源时，没有获得资源的阻塞等待唤醒
  - 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
- 公平锁/非公平锁
  - 相对于多线程而言
  - 公平锁的优点：等待锁的线程不会饥饿等待
  - 公平锁的缺点：整体吞吐效率相对非公平锁要低
  - 非公平锁的优缺点：
    - 整体的吞吐效率高，CPU 不必唤醒所有线程
    - 会出现饥饿等待
- 可重入锁/不可重入锁
  - 重入：任意线程获取锁以后，这个线程再次获得该锁时不会阻塞
  - 可重入锁又名递归锁：是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已获取过还没释放而阻塞
  - 不可重入锁：当前线程再次获取当前线程已经获得的锁时，如果该锁仍被当前线程所持有，未被释放，那么将会出现死锁
- 共享锁/排他锁
  - 排他锁（互斥锁）是指该锁一次只能被一个线程所持有
  - 共享锁：指该锁可被多个线程所持有
  - 获得共享锁的线程只能读数据，不能修改数据

## 进程间通信

不同进程的线程间通信需要依赖进程间通信的方法

- 进程间的同步方式

  - 管道
    - `|` 就是管道的意思，`|`前面部分作为`|`后面的输入
  - 消息队列
    - 单机进程间通信
    - 跨机进程间通信
      - 进程间通信的管道 `Kafka, RabbitMQ`
  - 共享内存
    - 在某种程度上，多进程是共同使用物理内存的
    - 由于操作系统的进程管理，进程间的内存空间是独立的
    - 共享存储允许不相关的进程访问同一片物理内存
    - 共享内存是两个进程之间共享和传递数据最快的方式
    - 共享内存不提供同步机制，需要借助其他机制管理访问
  - 信号
    - 操作系统中，不同信号使用不同的值来表示
    - 接收信号的进程需要注册对应的信号处理函数
  - 套接字 socket
    - 套接字原是网络通信中使用的术语
    - 域套接字是一种高级的进程间通信的方法
    - Unix 域套接字可以用于同一机器间的通信
    - Unix 系统提供的域套接字提供了网络套接字类似的功能
    - **Unix 域套接字通信无需经过完整的网络协议栈**

- 进程 VS 线程

  - 线程是系统进行运行调度的最小单位
  - 进程是系统进行资源分配和调度的基本单位

- 网络层：提供主机之间的通信
- 传输层：提供主机不同进程间的通信
- 应用层：提供不同应用之间的通信

```shell
# 查看占用8080端口
netstat -anlp | grep 8080
# 查看 筛选日志(和线程相关的错误日志)
cat server.log | grep ERROR | grep Thread
# 查看文档
man netstat | more

# 创建 test_pipe 管道
mkfifo test_pipe
# 写入xxx到test_pipe
echo "xxx" > test_pipe
cat test_pipe

# 查看支持的信号列表
kill -l
```

## 线程间通信

- 互斥锁 mutex
  - 互斥量是最简单的线程同步的方法
  - 互斥量（互斥锁），处于两态之一的变量：解锁和加锁
  - 两个状态可以保证资源访问的串行
  - 操作系统层和高级语言都直接提供了接口，可以直接使用
- 读写锁 rwlock
  - 读写锁是一种特殊的自旋锁
  - 允许多个读者同时访问资源以提高读性能
  - 对于写操作则是互斥的
- 自旋锁 spin_lock
  - 自旋锁也是一种多线程同步的变量
  - 使用自旋锁的线程会反复检查变量是否可用
  - 自旋锁不会让出 CPU，是一种忙等待状态
  - 优点
    - 自旋锁避免了进程或线程上下文切换的开销
    - 操作系统内部很多地方使用的是自旋锁
    - 自旋锁不适合在单核 CPU 使用
- 条件变量 condition
  - 条件变量是一种相对复杂的线程同步方法
  - 条件变量允许线程睡眠，直到满足某种条件
  - 当满足条件时，可以向该线程信号，通知唤醒
  - `wait` `signal`
- 线程间有哪些通信方式

- 临界资源
  - 互斥锁：当一个线程访问临界资源时，互斥锁会拒绝另一个线程访问临界资源
  - 自旋锁：当一个线程访问临界资源时，锁会拒绝另外一个线程访问临界访问临界资源
  - 读写锁：
    - 临界资源多读少写
    - 读取的时候并不会改变临界资源的值

## 无锁结构

### 无锁数据结构原理

- 利用 CPU 原子性指令 CAS 来实现的
- CAS 原理与无锁技术

### 大量使用锁的弊端

- 开发难度：并行系统访问临界资源必须考虑加锁
- 墨菲定律：只要存在的一定会发生死锁
- 调度问题：低优先级线程持有锁导致高优先级线程无法执行
- 性能问题：满足一致性要求的前提下需要串行访问
- 锁粒度：锁粒度过小/过大，设计不当

### CAS

- 基石：CAS 技术（Compare & Set | Compare & Swap）
  - 原子性：一系列操作不可被中断的特性；这一系列操作要么全部执行完成，要么全部没有执行，不存在部分执行，部分未执行的情况
- Fetch And Add: 一般用来对变量做+1 的原子操作
- Test And Set: 写值到某个内存位置并传回其旧值
- LockQueue -> SwapTail -> FreeLock
  - CAS 操作，不锁队列
  - 循环重试，直至成功
- CAS 与 ABA 问题
  - ABA 问题是指 CAS 交换数据在多次操作后恢复原值而线程无法感知的问题
    - 当前线程以为旧值：tail=8
    - 实际旧值：tail=8 -> tail=9 => tail=8
    - 指针 版本号

```c
int compare_and_swap(int* reg, int oldval, int newval){
  int old_reg_val = *reg;
  if(old_reg_val == oldval){ // 比较旧值
    *reg = newval; // 交互新值
    return old_reg_val;
  }
}

void* push(queue* q, void* data) {
  void* old_tail, new_tail;
  do {
    old_tail = q ->tail;
    new_tail = data;
  } while(!CAS(q->tail, old_tail, new_tail))
}
```

## 分布式锁

- 项目中分布式锁的实现方式
- 分布式锁场景
  - 分布式部署：集群、微服务
  - 服务节点之间需要通信
  - 数据强一致性要求、性能要求、并发量要求
- 秒杀系统-库存超卖
  - 订单系统、秒杀系统
  - 积分系统、消费系统
  - 消息中间件、服务中间件、数据发布-订阅
- 业界有哪些分布式锁框架
  - 基于 Redis
    - Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库
    - 读写性能优异
    - 内存读写，可持久化数据
    - 数据类型丰富、单线程、数据自动过期、发布-订阅
  - `setnx <key> <value>`
  - `del <key>`
  - 单点问题、雪崩效应
    - Redis 集群
      - 如何保证集群的一致性 --- Redis 集群原理
  - 基于 Zookeeper
    - ZooKeeper 是一个分布式的，开发源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件
    - 它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等
    - 如何工作
      - Zookeeper 数据节点：znode
      - 服务 1 在 Zookeeper 创建 znode1
      - 服务 2 在 Zookeeper 创建 znode1 失败
      - 服务 1 释放 znode，服务 2 创建成功
    - 临时节点：临时节点由某个客户端创建，当客户端与 ZK 集群断开连接，则该节点自动被删除
  - 基于传统的数据库：MySQL
    - MySQL 提供一致性服务：事务、表级锁、行级锁
    - UNIQUE KEY: 表级唯一，不能重复插入
    - 通过 MySQL 保证同一个 KEY 只有一个节点能插入成功
    - 通过删除记录释放锁
    - 把锁竞争的压力交给了 MySQL，且 MySQL 同样存在单点问题，需要集群解决
  - 京东：SharkLock
  - Google: Chubby
  - Netflix: Curator
  - Redisson
  - ETCD
  - consul
