# 常见面试题

## js 类型判断

- 1. `typeof` 返回 String
- 2. `instanceof` 返回 bool
  - `arr instanceof Array`
  - `arr instanceof Function`
  - `arr instanceof Object`
- 3. `Object.prototype.toString().call(xxxx)` 返回 String `[object Type]`

```js
function getType(obj) {
  // -1 => 一直截取到倒数第一个字符（不包含该字符本身）
  return Object.prototype.toString.call(obj).slice(8, -1);
}

console.log(getType([])); // "Array"
console.log(getType({})); // "Object"
console.log(getType(new Date())); // "Date"
```

## call apply bind

- 改变函数上下文的方法，作用：指定函数内部 this 的值，以及传递参数

- call: 接受多个参数，第一个参数调用函数的上下文，即函数内部的 this 值，后面参数是传递给函数的参数
- apply: 和 call 类似，但不同的是，参数是数组（call 是一个个单独的）
- bind: 只指定上下文，并返回新的函数，即不立即调用

```js
function add(a, b) {
  return a + b + this.c;
}
const obj1 = { c: 1 };
const obj2 = { c: 2 };

console.log(add.call(obj1, 3, 4));
console.log(add.call(obj2, 3, 4));

console.log(add.apply(obj1, [3, 4]));
console.log(add.apply(obj2, [3, 4]));

const bindA = add.bind(obj1);
const bindB = add.bind(obj2);
console.log(bindA(3, 4));
console.log(bindB(3, 4));
```

## Event Loop

在 JavaScript 中，事件循环`EventLoop`是一种机制，用于协调处理异步任务的执行顺序。  
JavaScript 是一门单线程语言，它只能同时处理一个任务，因此异步任务的执行需要借助事件循环机制来协调。  
事件循环的基本流程是：

- 执行同步任务，直到遇到第一个异步任务
- 将异步任务添加到任务队列中，继续执行同步任务
- 当异步任务完成时，将其对应的回调函数添加到任务队列中
- 等待同步任务执行完毕，查看任务队列中是否有任务
- 如果有任务，则按照添加顺序依次取出任务并执行其对应的回调函数，否则继续等待

- 在事件循环中，任务队列为两种类型
  - 宏任务 Macro Task: setTimeout, setInterval, setImmediate, I/O 等
  - 微任务 Micro Task: Promise, process.nextTick 等

事件循环的执行顺序是：先执行当前的宏任务中的同步代码，然后执行当前宏任务中的微任务，在取出下一个宏任务并执行。这个过程不断重复，直到所以任务都执行完毕。

```js
console.log(1);
new Promise((res, rej) => {
  console.log(3);
  setTimeout(res(4), 1000);
  Promise.resolve().then(() => {
    console.log(5);
  });
})
  .then((res) => {
    console.log(res);
    return;
  })
  .then((res) => {
    console.log(res);
  });
setTimeout(() => {
  console.log(9);
}, 0);
console.log(2); //   1  3 2  5  4  und 9
```

## setState

- setState 为什么是异步的
  - React 之所以将 setState 设计为异步的，是为了提高性能。当设置状态时，React 会将多个 setState 调用合并为一个批量更新，以减少不必要的 DOM 操作和渲染
- 如何在 setState 中获取先前的状态值
  - `setState(prevState=>({count: prevState.count+1}))`
- 如何避免 setState 后造成的不必要的渲染
  - 可以使用 shouldComponentUpdate 生命周期方法或`React.memo`高阶组件来避免不必要的渲染，或将状态拆分为多个单独的状态，以便更精确的控制更新

## useEffect

- useEffect 是 Reack 提供的一个 Hook，用于在组件渲染后执行副作用操作(如数据的获取、订阅事件等)，并可以在组件卸载或重新渲染前清除副作用操作。useEffect 的原理是基于 React 的生命周期方法和依赖性来实现的。
- 当组件渲染后，React 会调用 useEffect 中传递的函数，并在下一次渲染前清除上一次副作用操作.
  - 如果 useEffect 的第二个参数是一个空数组，则副作用操作只会在组件挂载和卸载时执行。
  - 如果第二个参数不为空，则副作用操作会在组件挂载，卸载和依赖项变化时执行
- 有时候 useEffect 的值是一样的，但仍然会重新运行的原因是 useEffect 的第二个参数是一个值数组，而不是一个引用数组。如果数组中的值在每次渲染时都是新的，即使他们的值相同，useEffect 也会重新运行。**这是因为在每次渲染时，React 都会创建一个新的数组对象，即使数组中的值没有改变**
  - 可以用`useMemo Hook`将其缓存为一个稳定的引用，以避免在每次渲染时都重新计算依赖项的值。

```js
import React, { useState, useEffect } from "react";
function FilteredList({ data, value }) {
  const [filteredData, setFilteredData] = useState([]);
  const filtered = useMemo(() => {
    return data.filter((item) => item.includes(value));
  }, [data, value]);
  const preRef = useRef(filtered);
  useEffect(() => {
    if (preRef.current !== filtered) {
      setFilteredData(filtered);
      preRef.current = filtered;
    }
  }, [filtered]);
  return (
    <ul>
      {filteredData.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  );
}
export default FilteredList;
```

### 为什么在每次渲染时，React 都会创建一个新的数组对象，即使数组中的值没有改变

- React 中，useState 和 useEffect 的依赖项都是基于引用比较的。这就意味着，如果一个依赖项是**一个对象或数组**，即使其值没有改变，只要它的引用发生变化，react 都会认为它已经发生了改变，从而触发重新渲染。
  - 为了避免不必要的渲染，可以使用 useCallback 和 useMemo 来缓存回调函数和计算结果，以确保他们的依赖项没有改变时不会重新计算
  - 依赖项用值类型

## useMemo

useMemo 是 React 提供的一个 Hook，它用于缓存计算结果，以避免在每次渲染时都重新计算结果。  
useMemo 的原理是基于 memoization 技术实现的。
memoization 是一种优化技术，它用于缓存函数的计算结果，以避免重复计算。当一个函数被多次调用时，memoization 可以缓存这个函数的计算结果，并在下一次调用时返回缓存的结果，而不是重新计算一遍，这样可以提高函数的执行效率。

- 选择的依赖项尽可能的稳定和最小化

```js
function calculateResult(data) {
  //计算结果
  return data;
}
function MyComponent({ data }) {
  const getData = useCallback(() => {
    return calculateResult(data);
  }, [data]);
  const result = useMemo(() => getData, [data]);
  useEffect(() => {
    console.log(1);
  }, [result]);
  return <ChaildComponent result={result} />;
}
const ChaildComponent = React.memo(({ result }) => {
  // 渲染组件
});
```

```js
// JSON.stringify() 或第三方库（如 lodash 的 isEqual() 方法）对比较对象或数组的值是否相等。
/// 最佳实践
const [a, setA] = useState(["1"]);
useEffect(() => {
  console.log(a);
  setInterval(() => {
    console.log(11111);
    setA(["1"]);
  }, 100);
}, []);
const aa = useCallback(() => {
  return JSON.stringify(aaa);
}, [a]);
const aaa = useMemo(() => aa, [aa]);
useEffect(() => {
  console.log("333");
}, []);
```

## React 底层

React 是一个用于构建用户界面的 JavaScript 库，它的底层实现主要涉及一下几个方面：

- 虚拟 DOM: React 使用虚拟 DOM 作为其底层实现的核心。虚拟 DOM 是一个轻量级的 JavaScript 对象树，用于描述 UI 元素的层次结构和属性。React 使用虚拟 DOM 来优化 DOM 操作，并提高应用性能。
- 组件化
- 生命周期
- 状态管理
- jsx

### 常见面试题

#### 虚拟 DOM, 组件化，状态管理，生命周期，JSX，事件处理，条件渲染，Hook 和组件通信等

- 什么是虚拟 DOM，作用是什么
- React 生命周期
- 什么是 React 的状态管理，它是如何工作的, 有哪些常用的状态管理方案，即方案的优缺点
- 什么是组件化，React 是如何实现组件化的
- React 中如何处理表单输入，如何处理多个输入的情况
- 什么是 JSX, 如何与 JavaScript 集成
- React 中的事件处理是如何工作的
- React 中如何进行条件渲染
- 什么是 React Hook，它是如何工作的
- React 中如何进行组件间的通信

#### 异步操作、性能优化、列表渲染、样式管理、高阶组件、动画处理、错误边界、代码分割和懒加载等

- 什么是 React 中的异步渲染，有什么作用
- React 中如何处理异步操作，如何使用`async/await`
- 什么是 React 中的上下文(Context), 它是如何工作的
- React 中如何进行性能优化，有哪些常见的优化技巧
- React 中如何处理列表渲染，有哪些常见的列表渲染技巧
- 什么是 React 中的 refs? 他们有什么作用
- React 中如何进行样式管理，有哪些常用的样式管理方案
- 什么是 React 中的高阶组件(HOC), 他们有什么作用
- React 中如何进行动画处理，有哪些常用的动画方案
- 什么是 React 中的错误边界(Error Boundary)，有什么作用
- React 中如何进行代码分割和懒加载，有哪些常见代码分割方案
- React 是如何进行测试的，哪些常用测试方案
- 什么是 React 中的可持续性(Sustainability)? 他们有什么作用
- React 是如何进行数据流管理的，有哪些常用的数据流管理方案
- 什么是 React 中的状态提升(StateLifting), 他们有什么作用
- React 中如何进行代码重构和优化，有哪些常用的重构和优化技巧
- 什么是 React 中的性能监测和调试，有哪些常用的性能监测和调试工具
- 什么是 React 中的代码分析和优化，有哪些常用的分析和优化工具

- 什么是 React 中的错误处理，常见的错误处理场景有哪些
- React 是如何进行多语言支持的
- React 中的服务端渲染及作用
- 函数式组件的作用
- 有哪些动态组件加载的方案
- 什么是 React 中的数据缓存

### 什么是虚拟 DOM，作用是什么

虚拟 DOM 是 React 中的一种机制，它是一个轻量级的 JavaScript 对象树，用于描述真实的 DOM 树的结构和属性。
在组件状态变化时，React 会使用虚拟 DOM 来计算出最小的 DOM 操作，然后将这些操作批量地应用到真实 DOM 上，从而实现高效的页面更新。

#### 作用

- 提高性能：虚拟 DOM 可以减少直接操作真实 DOM 的次数，从而提高页面的渲染性能
- 简化操作：虚拟 DOM 将复杂的 DOM 操作抽象成简单的 JavaScript 对象操作，从而简化开发人员的操作
- 跨平台支持：虚拟 DOM 可以在服务器端和客户端共享，从而实现跨平台支持
  - 服务器端渲染：虚拟 DOM 可以在服务器端进行渲染，生成 HTML 字符串，并将这些字符串发生到客户端，客户端在接收到 HTML 字符串后，会将其转换为虚拟 DOM，并通过 React 客户端渲染机制进行渲染
  - ReactNative 使用虚拟 DOM
- 支持动态更新：虚拟 DOM 可以动态更新，从而使得 React 应用可以快速的响应用户的操作

#### React 中实现虚拟 DOM 的核心模块

- ReactElement
  - ReactElement 是 React 中的一个重要概念，它表示 React 中的一个元素。ReactElement 是一个 JavaScript 对象，它包含了元素类型、属性和子元素等信息。在虚拟 DOM 中，ReactElement 被用来描述虚拟 DOM 树中的节点。
- ReactDOM
  - ReactDOM 是 React 中的一个模块，它提供了与 DOM 相关的操作。比如渲染元素、更新元素、删除元素等。在虚拟 DOM 中，ReactDOM 负责将虚拟 DOM 树转换为真实 DOM 树，并将差异更新到真实 DOM 上。
  - ReactNative 中，将 ReactDOM 树渲染成原生组件是在虚拟 DOM 的更新阶段完成的
    - 当 React 组件发生变化时，React 会重新计算虚拟 DOM 树，并将计算出的差异应用到原生组件上。在这个过程中，React 会遍历虚拟 DOM 树，找出需要更新的节点，然后将他们转换为相应的原生组件，并将更新应用到原生组件上
    - 这个过程中，ReactNative 会通过 UIManager 模块来操作原生组件。
      - UIManager 是 ReactNative 的核心模块，它提供了一组接口，用于操作原生组件，比如创建组件、更新组件、删除组件等
      - ReactNative 会通过 nUIManager 将虚拟 DOM 树转换为原生组件，并将差异更新到原生组件上
  - **ReactNative 应用的渲染时间可能会比原生更长**，因为 JavaScript 代码和原生代码是分离的。ReactNative 使用了以下技术来优化应用性能：
    - 虚拟 DOM
    - 异步渲染
      - 使用异步渲染将 UI 渲染操作分解成多个小任务，并在多个帧之间分配和执行这些任务，从而提高渲染的效率和流畅度
    - 批量更新
      - 将多个更新操作批量处理，从而减少不必要的 UI 更新操作，提高更新效率和性能
    - 原生组件复用

### React 的生命周期

- Mounting 挂载
  - `constructor()`: 组件创建时调用，用于初始化状态和绑定事件处理方法
  - `static getDerivedStateFromProps()`: 在组件创建和更新时调用，用于根据 props 计算并返回新的 state
  - `render()`: 必须实现的方法，用于返回组件的 JSX 模板
  - `componentDidMount()`: 组件挂载后调用，可以在该方法中进行 DOM 操作、网络请求等
- Updating 更新
  - `static getDerivedStateFromProps()`: 在组件创建和更新时调用，用于根据 props 计算并返回新的 state
  - `componentDidUpdate()`: 组件更新后调用，可以在该方法中进行 DOM 操作，网络请求等
  - `render()`: 必须实现的方法，用于返回组件的 JSX 模板
- Unmounting 卸载
  - `componentWillUnmount()`: 组件卸载前调用，可以在该方法中进行清理工作，如清除定时器、取消网络请求等
- 错误处理方法
  - `static getDerivedStateFromError()`: 在子组件抛出异常后调用，返回新的 state 以更新 UI
  - `componentDidCatch()`: 在子组件抛出异常后调用，用于记录错误日志等操作
- React17 版本中，`componentWillMount`, `componetWillReceiveProps`, `componentWillUpdate` 被标记为过时

### 什么是 React 的状态管理，它是如何工作的, 有哪些常用的状态管理方案，即方案的优缺点

状态管理重要包括：组件内部状态、跨组件状态、全局状态等

- 内部状态 => setState()
- 组件间的状态
  - **React Context API**: 通过提供全局的状态容器来管理应用程序的状态，即`Provider`和`Consumer`来实现状态共享和传递
    - 因为每次状态更新都会重新渲染所有使用该状态的组件，所以性能会受到影响
  - **Redux**: 通过提供一个 store 来管理状态，并使用 action 和 reducer 来实现状态更新
  - **MobX**

#### Context

```jsx
// Context
import React from "react";
const ThemeContext = React.createContext("light");
export default ThemeContext;

// Provider
import React from "react";
import ThemeContext from "./ThemeContext";
const App = ()=>{
  const [theme, setTheme] = React.useState("light");
  return (
    <ThemeContext.Provider value={{theme, setTheme}}>
      {/* 子组件 */}
    </ThemeContext.Provider>
  );
}
export default App;

// useContext
import ThemeContext from "./ThemeContext";
const Header = ()=>{
  const {theme} = React.useContext(ThemeContext);
  return (
    <header style={{backgroundColor: theme === 'light' ? '#ffffff' : '#000000'}}>
      {/* 渲染组件 */}
    </header>
  );
}
```

#### Redux

```js
// 创建 reducer 函数
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case "INCRE":
      return state + 1;
    case "DECRE":
      return state - 1;
    default:
      return state;
  }
};
// store
import { createStore } from "redux";
import counterReducer from "./counterReducer";
const store = createStore(counterReducer);
export default store;

// useSelector 获取计数器状态，useDispatch 来触发状态
import { useSelector, useDispatch } from "react-redux";
const Counter = () => {
  const count = useSelector((state) => state);
  const dispatch = useDispatch();
  const handleIncre = () => {
    dispatch({ type: "INCRE" });
  };
  const handleDecre = () => {
    dispatch({ type: "DECRE" });
  };
  return (
    <div>
      <button onClick={handleIncrement}>+</button>
      <span>{count}</span>
      <button onClick={handleDecrement}>-</button>
    </div>
  );
};
```

```js
// mobx  npm install mobx mobx-react --save
// store
import { observable, action } from "mobx";
class CounterStore {
  @observable count = 0;
  @action increment = () => {
    this.count += 1;
  };
  @action decrement = () => {
    this.count -= 1;
  };
}
const counterStore = new CounterStore();
export default counterStore;

// Provider
import { Provider } from "mobx-react";
import counterStore from "./counterStore";
import Counter from "./Counter";
const App = () => {
  return (
    <Provider counterStore={counterStore}>
      <Counter />
    </Provider>
  );
};

// 使用 inject 和 observer 函数来注入和观察 counterStore中的计数器状态
import React from "react";
import { inject, observer } from "mobx-react";
const Counter = ({counterStore})=>{
  const handleIncre = () => {
    dispatch({ type: "INCRE" });
  };
  const handleDecre = () => {
    dispatch({ type: "DECRE" });
  };
  return (<div>
    <button onClick={handleIncre}>+</button>
    <h1>{counterStore.count}</h1>
    <button onClick={handleDecre}>-</button>
  </div>)
}
export default inject("counterStore")(observer(Counter));


import React from "react";
import { inject, observer } from "mobx-react";
import counterStore from "./counterStore";
const AnotherComponent = ()=>{
    const handleIncre = () => {
    dispatch({ type: "INCRE" });
  };
  const handleDecre = () => {
    dispatch({ type: "DECRE" });
  };
  return (
    <div>
      <button onClick={handleIncre}>+</button>
      <h1>{counterStore.count}</h1>
      <button onClick={handleDecre}>-</button>
    </div>
  )
}
export default observer(AnotherComponent)
```
