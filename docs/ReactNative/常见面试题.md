# 常见面试题

## js 类型判断

- 1. `typeof` 返回 String
- 2. `instanceof` 返回 bool
  - `arr instanceof Array`
  - `arr instanceof Function`
  - `arr instanceof Object`
- 3. `Object.prototype.toString().call(xxxx)` 返回 String `[object Type]`

```js
function getType(obj) {
  // -1 => 一直截取到倒数第一个字符（不包含该字符本身）
  return Object.prototype.toString.call(obj).slice(8, -1);
}

console.log(getType([])); // "Array"
console.log(getType({})); // "Object"
console.log(getType(new Date())); // "Date"
```

## Promise 常用 api

- `Promise.all(iterable)`: 接收一个可迭代对象（如数组），返回一个新的 Promise
  - 所有的 Promise 都解决了，Promise 对象会被解决
  - 其中任何一个被拒绝，Promise 会被拒绝，并返回第一个拒绝原因
- `Promise.race(iterable)`: 接收一个可迭代对象（如数组），返回一个新的 Promise
  - 其中任何一个 Promise 对象被解决或拒绝，Promise 对象也会被解决或拒绝，并返回第一个解决或拒绝结果
- `Promise.allSettled(iterable)`: 接收一个可迭代对象（如数组），返回一个新的 Promise
  - 当所有 Promise 对象都被解决或拒绝时，新的 Promise 对象也会被解决，并返回一个包含所有结果（无论是解决还是拒绝）的数组。
- `Promise.any(iterable)`: 接收一个可迭代对象（如数组），返回一个新的 Promise
  - 其中任何一个 Promise 对象被解决时，新的 Promise 对象会被解决
  - 当所有 Promise 对象都被拒绝，则新的 Promise 也会被拒绝，并返回 AggregateError 对象，包含所有拒绝原因。
- `Promise.resolve(value)`:
- `Promise.reject(reason)`:
- `Promise.prototype.then(onResolved, onRejected)`:
- `Promise.prototype.catch(onRejected)`: 返回一个新的 Promise 对象
  - 当 Promise 对象被拒绝执行相应的回调函数，并返回拒绝原因
  - 回调函数发生错误，不会被 catch 捕获
- `Promise.prototype.finally(onFinally)`:
  - Promise 对象被解决或拒绝或取消，都会执行 finally

## call apply bind

- 改变函数上下文的方法，作用：指定函数内部 this 的值，以及传递参数

- call: 接受多个参数，第一个参数调用函数的上下文，即函数内部的 this 值，后面参数是传递给函数的参数
- apply: 和 call 类似，但不同的是，参数是数组（call 是一个个单独的）
- bind: 只指定上下文，并返回新的函数，即不立即调用

```js
function add(a, b) {
  return a + b + this.c;
}
const obj1 = { c: 1 };
const obj2 = { c: 2 };

console.log(add.call(obj1, 3, 4));
console.log(add.call(obj2, 3, 4));

console.log(add.apply(obj1, [3, 4]));
console.log(add.apply(obj2, [3, 4]));

const bindA = add.bind(obj1);
const bindB = add.bind(obj2);
console.log(bindA(3, 4));
console.log(bindB(3, 4));
```

## Event Loop

在 JavaScript 中，事件循环`EventLoop`是一种机制，用于协调处理异步任务的执行顺序。  
JavaScript 是一门单线程语言，它只能同时处理一个任务，因此异步任务的执行需要借助事件循环机制来协调。  
事件循环的基本流程是：

- 执行同步任务，直到遇到第一个异步任务
- 将异步任务添加到任务队列中，继续执行同步任务
- 当异步任务完成时，将其对应的回调函数添加到任务队列中
- 等待同步任务执行完毕，查看任务队列中是否有任务
- 如果有任务，则按照添加顺序依次取出任务并执行其对应的回调函数，否则继续等待

- 在事件循环中，任务队列为两种类型
  - 宏任务 Macro Task: setTimeout, setInterval, setImmediate, I/O 等
  - 微任务 Micro Task: Promise, process.nextTick 等

事件循环的执行顺序是：先执行当前的宏任务中的同步代码，然后执行当前宏任务中的微任务，在取出下一个宏任务并执行。这个过程不断重复，直到所以任务都执行完毕。

```js
console.log(1);
new Promise((res, rej) => {
  console.log(3);
  setTimeout(res(4), 1000);
  Promise.resolve().then(() => {
    console.log(5);
  });
})
  .then((res) => {
    console.log(res);
    return;
  })
  .then((res) => {
    console.log(res);
  });
setTimeout(() => {
  console.log(9);
}, 0);
console.log(2); //   1  3 2  5  4  und 9
```

## setState

- setState 为什么是异步的
  - React 之所以将 setState 设计为异步的，是为了提高性能。当设置状态时，React 会将多个 setState 调用合并为一个批量更新，以减少不必要的 DOM 操作和渲染
- 如何在 setState 中获取先前的状态值
  - `setState(prevState=>({count: prevState.count+1}))`
- 如何避免 setState 后造成的不必要的渲染
  - 可以使用 shouldComponentUpdate 生命周期方法或`React.memo`高阶组件来避免不必要的渲染，或将状态拆分为多个单独的状态，以便更精确的控制更新

## useEffect

- useEffect 是 Reack 提供的一个 Hook，用于在组件渲染后执行副作用操作(如数据的获取、订阅事件等)，并可以在组件卸载或重新渲染前清除副作用操作。useEffect 的原理是基于 React 的生命周期方法和依赖性来实现的。
- 当组件渲染后，React 会调用 useEffect 中传递的函数，并在下一次渲染前清除上一次副作用操作.
  - 如果 useEffect 的第二个参数是一个空数组，则副作用操作只会在组件挂载和卸载时执行。
  - 如果第二个参数不为空，则副作用操作会在组件挂载，卸载和依赖项变化时执行
- 有时候 useEffect 的值是一样的，但仍然会重新运行的原因是 useEffect 的第二个参数是一个值数组，而不是一个引用数组。如果数组中的值在每次渲染时都是新的，即使他们的值相同，useEffect 也会重新运行。**这是因为在每次渲染时，React 都会创建一个新的数组对象，即使数组中的值没有改变**
  - 可以用`useMemo Hook`将其缓存为一个稳定的引用，以避免在每次渲染时都重新计算依赖项的值。

```js
import React, { useState, useEffect } from "react";
function FilteredList({ data, value }) {
  const [filteredData, setFilteredData] = useState([]);
  const filtered = useMemo(() => {
    return data.filter((item) => item.includes(value));
  }, [data, value]);
  const preRef = useRef(filtered);
  useEffect(() => {
    if (preRef.current !== filtered) {
      setFilteredData(filtered);
      preRef.current = filtered;
    }
  }, [filtered]);
  return (
    <ul>
      {filteredData.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  );
}
export default FilteredList;
```

### 为什么在每次渲染时，React 都会创建一个新的数组对象，即使数组中的值没有改变

- React 中，useState 和 useEffect 的依赖项都是基于引用比较的。这就意味着，如果一个依赖项是**一个对象或数组**，即使其值没有改变，只要它的引用发生变化，react 都会认为它已经发生了改变，从而触发重新渲染。
  - 为了避免不必要的渲染，可以使用 useCallback 和 useMemo 来缓存回调函数和计算结果，以确保他们的依赖项没有改变时不会重新计算
  - 依赖项用值类型

## useMemo

useMemo 是 React 提供的一个 Hook，它用于缓存计算结果，以避免在每次渲染时都重新计算结果。  
useMemo 的原理是基于 memoization 技术实现的。
memoization 是一种优化技术，它用于缓存函数的计算结果，以避免重复计算。当一个函数被多次调用时，memoization 可以缓存这个函数的计算结果，并在下一次调用时返回缓存的结果，而不是重新计算一遍，这样可以提高函数的执行效率。

- 选择的依赖项尽可能的稳定和最小化

```js
function calculateResult(data) {
  //计算结果
  return data;
}
function MyComponent({ data }) {
  const getData = useCallback(() => {
    return calculateResult(data);
  }, [data]);
  const result = useMemo(() => getData, [data]);
  useEffect(() => {
    console.log(1);
  }, [result]);
  return <ChaildComponent result={result} />;
}
const ChaildComponent = React.memo(({ result }) => {
  // 渲染组件
});
```

```js
// JSON.stringify() 或第三方库（如 lodash 的 isEqual() 方法）对比较对象或数组的值是否相等。
/// 最佳实践
const [a, setA] = useState(["1"]);
useEffect(() => {
  console.log(a);
  setInterval(() => {
    console.log(11111);
    setA(["1"]);
  }, 100);
}, []);
const aa = useCallback(() => {
  return JSON.stringify(aaa);
}, [a]);
const aaa = useMemo(() => aa, [aa]);
useEffect(() => {
  console.log("333");
}, []);

import { isEqual } from "lodash";
async function useMemoWithDeepCompare<T, U extends any[]>(
  fun: (...args: U) => T,
  inputs: U,
) {
  const [value, setValue] = useState<T>();
  const inputsRef = useRef<U>();
  await useMemo(async () => {
    if (!isEqual(inputs, inputsRef.current)) {
      inputsRef.current = inputs;
      const _value = await fun(...inputs);
      setValue(_value);
    }
  }, [inputs]);
  return value;
}

useMemoWithDeepCompare<LIST, LIST>(() => {
  console.log('走到这了。。。');
  return lst;
}, lst).then(a => {
  console.log({a});
});
```

## React 底层

React 是一个用于构建用户界面的 JavaScript 库，它的底层实现主要涉及一下几个方面：

- 虚拟 DOM: React 使用虚拟 DOM 作为其底层实现的核心。虚拟 DOM 是一个轻量级的 JavaScript 对象树，用于描述 UI 元素的层次结构和属性。React 使用虚拟 DOM 来优化 DOM 操作，并提高应用性能。
- 组件化
- 生命周期
- 状态管理
- jsx

### 常见面试题

#### 虚拟 DOM, 组件化，状态管理，生命周期，JSX，事件处理，条件渲染，Hook 和组件通信等

- 什么是虚拟 DOM，作用是什么
- React 生命周期
- 什么是 React 的状态管理，它是如何工作的, 有哪些常用的状态管理方案，即方案的优缺点
- 什么是组件化，React 是如何实现组件化的
- React 中如何处理表单输入，如何处理多个输入的情况
- 什么是 JSX, 如何与 JavaScript 集成
- React 中的事件处理是如何工作的
- React 中如何进行条件渲染
- 什么是 React Hook，它是如何工作的
- React 中如何进行组件间的通信

#### 异步操作、性能优化、列表渲染、样式管理、高阶组件、动画处理、错误边界、代码分割和懒加载等

- 什么是 React 中的异步渲染，有什么作用
- React 中如何处理异步操作，如何使用`async/await`
- 什么是 React 中的上下文(Context), 它是如何工作的
- React 中如何进行性能优化，有哪些常见的优化技巧
- React 中如何处理列表渲染，有哪些常见的列表渲染技巧
- 什么是 React 中的 refs? 他们有什么作用
- React 中如何进行样式管理，有哪些常用的样式管理方案
- 什么是 React 中的高阶组件(HOC), 他们有什么作用
- React 中如何进行动画处理，有哪些常用的动画方案
- 什么是 React 中的错误边界(Error Boundary)，有什么作用
- React 中如何进行代码分割和懒加载，有哪些常见代码分割方案
- React 是如何进行测试的，哪些常用测试方案
- 什么是 React 中的可持续性(Sustainability)? 他们有什么作用
- React 是如何进行数据流管理的，有哪些常用的数据流管理方案
- 什么是 React 中的状态提升(StateLifting), 他们有什么作用
- React 中如何进行代码重构和优化，有哪些常用的重构和优化技巧
- 什么是 React 中的性能监测和调试，有哪些常用的性能监测和调试工具
- 什么是 React 中的代码分析和优化，有哪些常用的分析和优化工具

- 什么是 React 中的错误处理，常见的错误处理场景有哪些
- React 是如何进行多语言支持的
- React 中的服务端渲染及作用
- 函数式组件的作用
- 有哪些动态组件加载的方案
- 什么是 React 中的数据缓存

### 什么是虚拟 DOM，作用是什么

虚拟 DOM 是 React 中的一种机制，它是一个轻量级的 JavaScript 对象树，用于描述真实的 DOM 树的结构和属性。
在组件状态变化时，React 会使用虚拟 DOM 来计算出最小的 DOM 操作，然后将这些操作批量地应用到真实 DOM 上，从而实现高效的页面更新。

#### 作用

- 提高性能：虚拟 DOM 可以减少直接操作真实 DOM 的次数，从而提高页面的渲染性能
- 简化操作：虚拟 DOM 将复杂的 DOM 操作抽象成简单的 JavaScript 对象操作，从而简化开发人员的操作
- 跨平台支持：虚拟 DOM 可以在服务器端和客户端共享，从而实现跨平台支持
  - 服务器端渲染：虚拟 DOM 可以在服务器端进行渲染，生成 HTML 字符串，并将这些字符串发生到客户端，客户端在接收到 HTML 字符串后，会将其转换为虚拟 DOM，并通过 React 客户端渲染机制进行渲染
  - ReactNative 使用虚拟 DOM
- 支持动态更新：虚拟 DOM 可以动态更新，从而使得 React 应用可以快速的响应用户的操作

#### React 中实现虚拟 DOM 的核心模块

- ReactElement
  - ReactElement 是 React 中的一个重要概念，它表示 React 中的一个元素。ReactElement 是一个 JavaScript 对象，它包含了元素类型、属性和子元素等信息。在虚拟 DOM 中，ReactElement 被用来描述虚拟 DOM 树中的节点。
- ReactDOM
  - ReactDOM 是 React 中的一个模块，它提供了与 DOM 相关的操作。比如渲染元素、更新元素、删除元素等。在虚拟 DOM 中，ReactDOM 负责将虚拟 DOM 树转换为真实 DOM 树，并将差异更新到真实 DOM 上。
  - ReactNative 中，将 ReactDOM 树渲染成原生组件是在虚拟 DOM 的更新阶段完成的
    - 当 React 组件发生变化时，React 会重新计算虚拟 DOM 树，并将计算出的差异应用到原生组件上。在这个过程中，React 会遍历虚拟 DOM 树，找出需要更新的节点，然后将他们转换为相应的原生组件，并将更新应用到原生组件上
    - 这个过程中，ReactNative 会通过 UIManager 模块来操作原生组件。
      - UIManager 是 ReactNative 的核心模块，它提供了一组接口，用于操作原生组件，比如创建组件、更新组件、删除组件等
      - ReactNative 会通过 UIManager 将虚拟 DOM 树转换为原生组件，并将差异更新到原生组件上
  - **ReactNative 应用的渲染时间可能会比原生更长**，因为 JavaScript 代码和原生代码是分离的。ReactNative 使用了以下技术来优化应用性能：
    - 虚拟 DOM
    - 异步渲染
      - 使用异步渲染将 UI 渲染操作分解成多个小任务，并在多个帧之间分配和执行这些任务，从而提高渲染的效率和流畅度
    - 批量更新
      - 将多个更新操作批量处理，从而减少不必要的 UI 更新操作，提高更新效率和性能
    - 原生组件复用

### React 的生命周期

- Mounting 挂载
  - `constructor()`: 组件创建时调用，用于初始化状态和绑定事件处理方法
  - `static getDerivedStateFromProps()`: 在组件创建和更新时调用，用于根据 props 计算并返回新的 state
  - `render()`: 必须实现的方法，用于返回组件的 JSX 模板
  - `componentDidMount()`: 组件挂载后调用，可以在该方法中进行 DOM 操作、网络请求等
- Updating 更新
  - `static getDerivedStateFromProps()`: 在组件创建和更新时调用，用于根据 props 计算并返回新的 state
  - `render()`: 必须实现的方法，用于返回组件的 JSX 模板
  - `getSnapshotBeforeUpdate`
  - `componentDidUpdate()`: 组件更新后调用，可以在该方法中进行 DOM 操作，网络请求等
- Unmounting 卸载
  - `componentWillUnmount()`: 组件卸载前调用，可以在该方法中进行清理工作，如清除定时器、取消网络请求等
- 错误处理方法
  - `static getDerivedStateFromError()`: 在子组件抛出异常后调用，返回新的 state 以更新 UI
  - `componentDidCatch()`: 在子组件抛出异常后调用，用于记录错误日志等操作
- React17 版本中，`componentWillMount`, `componetWillReceiveProps`, `componentWillUpdate` 被标记为过时

### 什么是 React 的状态管理，它是如何工作的, 有哪些常用的状态管理方案，即方案的优缺点

状态管理重要包括：组件内部状态、跨组件状态、全局状态等

- 内部状态 => setState()
- 组件间的状态
  - **React Context API**: 通过提供全局的状态容器来管理应用程序的状态，即`Provider`和`Consumer`来实现状态共享和传递
    - 因为每次状态更新都会重新渲染所有使用该状态的组件，所以性能会受到影响
  - **Redux**: 通过提供一个 store 来管理状态，并使用 action 和 reducer 来实现状态更新
  - **MobX**

#### Context

- 如果需要再组件树中共享简单的数据和状态，如主题，语言，用户状态等，可以用 context
- 如果需要管理较为复杂的应用程序状态，如购物车、路由、网络请求等，可以用 store

```jsx
// Context
import React from "react";
const ThemeContext = React.createContext("light");
export default ThemeContext;

// Provider
import React from "react";
import ThemeContext from "./ThemeContext";
const App = ()=>{
  const [theme, setTheme] = React.useState("light");
  return (
    <ThemeContext.·Provider ·value={{theme, setTheme}}>
      {/* 子组件 */}
    </ThemeContext.Provider>
  );
}
export default App;

// useContext
import ThemeContext from "./ThemeContext";
const Header = ()=>{
  const {theme} = React.useContext(ThemeContext);
  return <header style={{backgroundColor: theme === 'light' ? '#ffffff' : '#000000'}}>
      {/* 渲染组件 */}
    </header>;
}
```

#### Redux

```js
// 创建 reducer 函数
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case "INCRE":
      return state + 1;
    case "DECRE":
      return state - 1;
    default:
      return state;
  }
};
// store
import { createStore } from "redux";
import counterReducer from "./counterReducer";
const store = createStore(counterReducer);
export default store;

// useSelector 获取计数器状态，useDispatch 来触发状态
import { useSelector, useDispatch } from "react-redux";
const Counter = () => {
  const count = useSelector((state) => state);
  const dispatch = useDispatch();
  const handleIncre = () => {
    dispatch({ type: "INCRE" });
  };
  const handleDecre = () => {
    dispatch({ type: "DECRE" });
  };
  return (
    <div>
      <button onClick={handleIncrement}>+</button>
      <span>{count}</span>
      <button onClick={handleDecrement}>-</button>
    </div>
  );
};
```

```js
// mobx  npm install mobx mobx-react --save
// store
import { observable, action } from "mobx";
class CounterStore {
  @observable count = 0;
  @action increment = () => {
    this.count += 1;
  };
  @action decrement = () => {
    this.count -= 1;
  };
}
const counterStore = new CounterStore();
export default counterStore;

// Provider
import { Provider } from "mobx-react";
import counterStore from "./counterStore";
import Counter from "./Counter";
const App = () => {
  return (
    <Provider counterStore={counterStore}>
      <Counter />
    </Provider>
  );
};

// 使用 inject 和 observer 函数来注入和观察 counterStore中的计数器状态
import React from "react";
import { inject, observer } from "mobx-react";
const Counter = ({counterStore})=>{
  const handleIncre = () => {
    dispatch({ type: "INCRE" });
  };
  const handleDecre = () => {
    dispatch({ type: "DECRE" });
  };
  return (<div>
    <button onClick={handleIncre}>+</button>
    <h1>{counterStore.count}</h1>
    <button onClick={handleDecre}>-</button>
  </div>)
}
export default inject("counterStore")(observer(Counter));


import React from "react";
import { inject, observer } from "mobx-react";
import counterStore from "./counterStore";
const AnotherComponent = ()=>{
    const handleIncre = () => {
    dispatch({ type: "INCRE" });
  };
  const handleDecre = () => {
    dispatch({ type: "DECRE" });
  };
  return (
    <div>
      <button onClick={handleIncre}>+</button>
      <h1>{counterStore.count}</h1>
      <button onClick={handleDecre}>-</button>
    </div>
  )
}
export default observer(AnotherComponent)
```

### React 中如何处理表单输入，如何处理多个输入的情况

```js
import React, { useState, useCallback } from "react";
import { debounce } from "lodash";
function useInputValidator(initialValue, validator, delay) {
  const [value, setValue] = useState(initalValue);
  const debouncedHandleChange = useCallback(
    debounce((value) => {
      if (validator(value)) {
        setValue(value);
      }
    }, delay),
    [delay, validator]
  );
  const handleChange = useCallback(
    (event) => {
      const value = event.target.value;
      debouncedHandleChange(value);
    },
    [debouncedHandleChange]
  );
  return [value, handleChange];
}
function TextInput({ onChange }) {
  const validator = useCallback((value) => {
    const regex = /^[a-zA-Z0-9]*$/; // 只允许输入英文字母和数字
    return regex.test(value);
  }, []);
  const [value, handleChange] = useInputValidator("", validator, 300);
  useEffect(() => {
    onChange(value);
  }, [value, onChange]);
  return <input type="text" value={value} onChange={handleChange} />;
}
```

### 什么是 JSX, 如何与 JavaScript 集成

JSX 是一种在 JavaScript 中嵌入 XML 标签的语法扩展，是 React 的核心特性之一。  
JSX 可以使在 JavaScript 中编写组件和 UI 变得更加直观和易于理解。

为了在 JavaScript 中使用 JSX，需要使用一个编译器（如 Babel）将 JSX 转换成普通的 JavaScript 代码。转换后的代码使用`React.createElement()`函数来创建 React 元素。

```js
// 第一个元素是标签，第二个是属性，第三个是标签子元素
const element = React.createElement("h1", null, "Hello, world!");
```

- 使用 Babel 编译器

```js
- npm install --save-dev @babel/preset-react
// .babelrc  或 balel.config.js 配置文件
// @babel/preset-react 转换jsx代码的插件
{
  "presets": ["@babel/preset-env", "@babel/preset-react"]
}
```

### React 中的事件处理是如何工作的

在 React 中，事件处理是通过在组件中定义事件处理函数来实现的。
当用户在组件上执行某个操作（比如单击按钮）时，React 会调用相应的事件处理函数来响应该操作。
React 中的事件处理和普通的 JavaScript 事件处理略有不同。

#### 特点

- **事件处理函数的定义**
  - 普通 JavaScript，可以使用 addEventListener 来为 DOM 元素绑定事件处理函数。
  - 在 React 中，可以使用内联事件处理器来为组件绑定事件处理函数。
- **合成事件对象**
  - 普通 JavaScript，接收一个事件对象参数
  - 在 React 中，接收一个合成事件对象参数
    - React 封装的一个对象，它把不同浏览器之间的事件行为进行了标准化，使得事件处理过程更加可靠和一致。
  - 合成事件对象包括
    - `event.target`: 获取触发点击事件的按钮元素
    - `event.type`: 事件类型，例如 click、keypress 等
    - `event.currentTarget`: 当前处理事件的 DOM 元素
    - `event.stopPropagation()`: 阻止事件冒泡
    - `event.preventDefault()`: 阻止事件的默认行为
- **事件委托**
  - 在传统事件处理中，需要为每个需要绑定事件的元素都绑定一个事件处理函数，这会导致代码冗余和性能问题。
  - 在 React 中，可以使用事件委托的方式来绑定事件处理函数。
    - 将事件处理函数绑定到父元素上，使得子元素的事件可以在父元素上进行处理。这样可以减少事件处理函数的数量，并提高性能。
    - 使用事件冒泡来捕获事件并在组件树中传递事件
- **事件池**
  - 传统 JavaScript 事件处理中，每触发事件都会创建一个新的事件对象，这会导致内存占用和性能问题。
  - 在 React 中，事件处理函数会从事件池中获取事件对象，以减少创建和销毁事件对象的开销。事件池是一种对事件对象进行重用的技术，使得事件处理过程更加高效。
  - 使用`React Developer Tools`来检查事件池和事件委托情况
- **事件队列**
  - 在 React 中，事件处理函数会被放入一个事件队列中，并按照顺序依次执行。这种方式可以确保事件处理函数的执行顺序是可预测的，避免多个事件处理函数之间的竞争关系。

```js
// 事件委托
class List extends React.Component {
  handleClick = (event) => {
    console.log("List item clicked: ", event.target);
  };
  render() {
    return (
      <ul onClick={this.handleClick}>
        <ListItem text="Item 1" />
        <ListItem text="Item 2" />
        <ListItem text="Item 3" />
        <ListItem text="Item 4" />
      </ul>
    );
  }
}
function ListItem() {
  return <li>{this.props.text}</li>;
}
```

#### React 的事件池和事件队列是在哪个模块里

React 的事件池和事件队列是在`ReactFiberEvents`模块中实现的。

- **ReactFiberEvents** 是 React 中新的协调器架构(Fiber Architecture)的一部分
  - 负责协调和调度组件更新和事件处理等任务
- 在 ReactFiberEvents 模块中, **EventPluginHub** 的对象是事件插件系统的核心。事件插件系统是 React 中处理事件的基础架构，可以让开发者编写自定义事件处理逻辑，并以 React 的事件处理逻辑进行集成。
- EventPluginHub 包含事件池和事件队列等数据结构，以及处理事件的核心逻辑。
- 事件队列是先进先出。当一个事件被加入到事件队列中时，EventPluginHub 会调度 ReactEventEmitter 对象来处理事件。ReactEventEmitter 对象会遍历事件队列，并依次执行每个事件的处理函数。

手写实现事件池和事件队列

```js
const eventPool = []; // 事件池
const eventQueue = []; // 事件队列
function createEvent(type, target) {
  const event = eventPool.length > 0 ? eventPool.pop() : {};
  event.type = type;
  event.target = target;
  return event;
}
function releaseEvent(event) {
  eventPool.push(event);
}
function addEventToQueue(event) {
  eventQueue.push(event);
}
function processEventQueue() {
  while (eventQueue.length > 0) {
    const event = eventQueue.shift();
    // 释放事件对象
    releaseEvent();
  }
}
// 在元素上绑定事件处理函数
function bindEventListener(element, eventType, handler) {
  const listener = function (evt) {
    const event = createEvent(eventType, element);
    handler(event);
    addEventToQueue(event);
  };
  element.addEventListener(eventType, listener);
}
// 创建DOM元素并绑定事件的处理函数
const button = document.createElement("button");
button.innerHTML = "CLICK ME";
bindEventListener(button, "click", (event) => {
  console.log("Button is Clicked");
});
button.click();
button.click();
button.click();
button.click();
// 处理事件队列
processEventQueue();
```

### React 中如何进行条件渲染

- 三元表达式
- 使用逻辑与&&
- 条件语句
- switch

```js
// 使用逻辑与&&
function App() {
  const isLoggedIn = true;
  return <div>{isLoggedIn && <p>ddddd</p>}</div>;
}
```

### React Hook 是如何工作的

React Hook 可以让函数组件与类组件一样具有状态`state`和生命周期方法`lifecycle methods`。
React Hook 的核心思想是将函数组件中的状态`state`和副作用`side effects`抽象成可复用的函数，通过特定的 Hook 函数来使用它。
React Hook 的实现原理是利用 React 的 Fiber 架构，它可以让 React 组件在渲染过程中暂停和恢复，从而能够处理异步和中断等情况。Hook 函数利用 Fiber 架构中的钩子(hook)机制，

- 在组件 render 过程中，通过特定的钩子函数来获取和更新状态，处理副作用等。React Hook 能够保证在多次渲染之间，状态和副作用的正确性和一致性。

```js
// 生命周期
function MyComp() {
  useEffect(() => {
    // 组件 mounted
    return () => {
      // 组件 unmounted
    };
  }, []);
}
function App() {
  const [hasError, error] = useErrorBoundary();
  return <div>{hasError ? <h1>{error.mssage}</h1> : <MyComp />}</div>;
}
```

- useErrorBoundary
- useLayoutEffect: 在组件更新之前同步执行，也就是说 useLayoutEffect 里的更新操作会在浏览器布局完成之前同步执行
- useImperativeHandle: 用于在函数组件中暴露自定义引用，例如访问子组件的方法或属性。
  - useImperativeHandle 只能用于 forwardRef 函数中

```js
// useLayoutEffect
function MyComponent() {
  const [width, setWidth] = useState(0);
  useLayoutEffect(() => {
    const handleResize = () => {
      setWidth(window.innderWidth);
    };
    handleResize();
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return <h1>window width: {width}px</h1>;
}
// useImperativeHandle
import {
  useRef,
  useEffect,
  forwardRef,
  useState,
  useImperativeHandle,
  useMemo,
} from "react";
const Child = forwardRef((props, ref) => {
  const [state, setState] = useState(0);
  useImperativeHandle(
    ref,
    () => {
      return {
        increment: () =>
          new Promise((res) => {
            setState(state + 1);
            res(state);
          }),
        decrement: () => setState(state - 1),
        getState: () => state,
      };
    },
    [state]
  );
  return <h1>{state}</h1>;
});
const App = () => {
  const childRef = useRef(null);
  const handleClick = async () => {
    const preValue = await childRef.current.increment();
    console.log(preValue);
    console.log(childRef.current.getState());
  };

  return (
    <div>
      <Child ref={childRef} />
      <button onClick={handleClick}>Increment</button>
    </div>
  );
};
export default App;
```

### React 中是如何进行组件间通信的

- Props
  - useImperativeHandle
- Context
- Store 全局状态管理器
- EventEmitter 事件

```js
// EventEmitter
const eventEmitter = new EventEmitter();
function ParentComponent() {
  const handleButtonClick = () => {
    eventEmitter.emit("increment");
  };
  return (
    <div>
      <ChildComponent />
      <button onClick={handleButtonClick}></button>
    </div>
  );
}
function ChildComponent() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const handleIncrement = () => {
      setCount(count + 1);
    };
    eventEmitter.addListener("increment", handleIncrement);
    return () => {
      eventEmitter.removeListener("increment", handleIncrement);
    };
  }, [count]);
  return <h1>Count: {count}</h1>;
}
```

### 什么是 React 中的异步渲染，有什么作用

- React 中的异步渲染是指 DOM 更新操作放入浏览器空闲时间操作。
- React16 引入了 Fiber 架构，Fiber 架构是一种新的调度算法，用于实现异步渲染和增量更新。
  - Fiber 架构将组件更新过程分为多个阶段，并允许 React 在不同阶段中断渲染，以便优先处理其他任务。这样可以在不阻塞主线程的情况下，提高页面响应速度和渲染性能。
- 提高页面响应速度
- 减少渲染开销
- 更好的用户体验
- 使用`React.lazy`和`Suspense`组件来实现异步渲染

```js
import React, { lazy, Suspense } from "react";
const AsyncComp = lazy(() => import("./comp"));
function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <AsyncComp />
    </Suspense>
  );
}
```

### 什么是 React 中的上下文，它是如何工作的

- React 中的上下文(Context)是一种跨层级组件通信的方式，它可以让开发者在组件树中共享数据。
- React 使用一种称为`订阅-发布`机制来实现上下文更新的。
  - React 会监测组件是否依赖用于上下文对象
  - 如果依赖于上下文对象，React 会将这个组件添加到上下文对象的订阅列表中
  - 在上下文提供者的值发生变化时，通过使用订阅这个上下文，组件进行重新渲染
  - 注意性能问题，避免不必要的重新渲染
- 通过`React.createContext`函数来创建的，`React.createContext`返回`Provider`和`Consumer`，分别代表上下文提供者和上下文消费者。
- `useContextSelector`是 React 中自定义钩子函数

```js
import React, { createContext, useContext } from "react";
import { useContextSelector } from "use-context-selectore";
const UserContext = createContext({
  firstName: "Aa",
  lastName: "D",
  age: 30,
});
function App() {
  return (
    <UserContext.Provider value={{ firestName: "A", lastName: "dsf", age: 23 }}>
      <Profile />
    </UserContext.Provider>
  );
}
function Profile() {
  const firstName = useContextSelector(UserContext, (user) => user.firstName);
  const age = useContextSelector(UserContext, (user) => user.age);
  return (
    <div>
      <p>First Name: {firstName}</p>
      <p>Age: {age}</p>
    </div>
  );
}
export default App;
```

### React 中如何进行性能优化，有哪些常见的优化技巧

- 使用`React.memo` 进行组件的记忆化
- 使用`useCallback`和`useMemo`进行函数和数据的缓存
  - useCallback 缓存函数，避免不必要的函数重新创建和引用变化
  - useMemo 缓存数据，避免不必要的重复计算
- 将组件分割成更小的组件。React 只会重新渲染发生变化的组件，而更小的组件意味着更少的更新。
- 使用`shouldComponentUpdate`或`shouldUpdate` 来判断组件是否需要重新渲染
- 使用`React.lazy`和`Suspense`进行组件懒加载，避免一次性加载所有组件，可以提高初始化加载速度，同时减少不必要的网络请求和资源浪费
- 使用`PureComponents`避免组件渲染时不必要的计算和比较
- 使用`React.Fragment`来避免额外的 DOM 嵌套
- 使用 Webpack 进行代码分割
  - 使用`splitChunksPlugin`插件来实现代码分割
    - 将公共模块提取到单独的 chunk 中，避免重复打包，从而减小打包后的文件体积
- 避免使用内联样式，会增加样式计算和解析时间
- 优化图片和静态资源，使用压缩和懒加载的方式进行优化
- 在处理大量数据时，使用虚拟列表和分页提高渲染性能
- 使用 Keys, 帮助 React 识别哪些元素需要更新，哪些元素需要添加或删除
- 避免在 render 中进行复杂的计算和操作
  - 可以考虑使用`useLayoutEffect`或`useEffect`进行渲染后的计算和操作
- 使用 ReactDevTool 进行性能分析
- 使用 ReactProfiler 进行性能分析

```js
// webpack配置，实现代码分割
module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "boundle.js",
    path: __dirname + "/dist",
  },
  optimization: {
    splitChunks: {
      // 设置splitChunks参数，将所有公共模块提取到一个名为vendors的chunk这，当应用需要更新时，只需要更新vendors chunk，而不需要更新所有代码
      chunks: "all",
    },
  },
};

// 懒加载
function App() {
  const [showComponent, setShowComponent] = useState(false);
  return (
    <div>
      {showComponent && (
        <React.Suspense fallback={<div>Loading</div>}>
          <LazyLoadedComp />
        </React.Suspense>
      )}
    </div>
  );
}
// 这里的 import() 返回的是一个 Promise 对象
const LazyLoadedComp = React.lazy(() => import("./comp"));
export default App;
```

```js
// 虚拟列表
import React, { useState, useEffect, useRef } from "react";
function VirtuallList({ data, itemHeight, containerHeight }) {
  const [startIndex, setStateIndex] = useState(0);
  const [endIndex, setEndIndex] = useState(
    Math.ceil(containerHeight / itemHeight)
  );
  const containerRef = useRef(null);

  useEffect(() => {
    const handleScroll = () => {
      const scrollTop = containerRef.current.scrollTop;
      setStartIndex(Math.floor(scrollTop / itemHeight));
      setEndIndex(Math.ceil((scrollTop + containerHeight) / itemHeight));
    };
    containerRef.current.addEventListener("scroll", handleScroll);
    return () => {
      containerRef.current.removeEventListener("scroll", handleScroll);
    };
  }, [itemHeight, containerHeight]);
  const visibleDate = data.slice(startIndex, endIndex);
  return (
    <div
      ref={containerRef}
      style={{ height: containerHeight, overflowY: "scroll" }}
    >
      <div style={{ height: data.length * itemHeight }}>
        {visibleData.map((item, index) => (
          <div key={index} style={{ height: itemHeight }}>
            {item}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### React 中如何处理列表渲染，有哪些常见的列表渲染技巧

- 分页
- 虚拟列表
- shouldComponentUpdate 或 memo 函数优化
- 使用 React.Fragment 来避免额外的 DOM 嵌套
- `react-virtualized`或`react-window`等三方库

### 什么是 React 中的 refs，他们有什么作用

- refs 是一种访问 DOM 元素或组件实例的机制。可以获取组件实例或 DOM 元素，并在需要时修改其属性和方法。
- React 是数据驱动 UI，应该尽量避免直接修改 DOM 或组件实例

```js
class App extends React.Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  handleClick = () => {
    this.inputRef.current.focus();
  };
  render() {
    return (
      <div>
        <input type="text" ref={this.inputRef} />
        <button onClick={this.handleClick}>Focus Input</button>
      </div>
    );
  }
}
```

#### refs 和 ref 有啥区别

- 实现方式不一样
- 使用场景不太同：`useRef`除了 DOM 元素和组件实例，还可以保存需要状态的变量

### React 中如何进行样式管理，有哪些常用的样式管理方案

- 内联样式
- css 模块
- css-in-js
- 三方 UI 库，包括 AntDesign, Material-UI, Bootstrap 等

```js
// 内联样式
function App() {
  const color = "red";
  const style = {
    color: color,
  };
  return <div style={style}>Helloe</div>;
}
```

```js
// css 模块
import styles from "./Button.module.css";
function Button(props) {
  return <button className={styles.button}>{props.children}</button>;
}
```

```js
// css-in-js
import styled from "styled-components";
const Button = styled.button`
  background-color: yellow;
  color: red;
`;
function App() {
  return <Button>xxx</Button>;
}
```

```js
// antd
import { Button } from "antd";
function App() {
  return <Button type="primary">Hello</Button>;
}
```

```js
// Material-UI
import React from "react";
import Button from "@material-ui/core/Button";
import { withStyles } from "@material-ui/core/styles";
const styles = {
  button: {
    fontSize: "25px",
  },
};
function App(props) {
  const { classes } = props;
  return (
    <div>
      <Button variant="contained" color="primary" className={classes.button}>
        Hello
      </Button>
    </div>
  );
}
export default withStyles(styles)(App);
```

### 什么是 React 中的高阶组件 HOC, 有什么作用

高阶组件(HOC)，是一种 React 组件的设计模式，可以接收一个组件作为参数，并返回一个新的组件。  
HOC 可以用来增强组件功能，例如添加共享状态或行为，修改组件的渲染方式等。
作用：

- 代码复用
- 组件增强
- 抽象层级
- HOC 可能嵌套过深过命名冲突，一般在 HOC 前面加上 with，避免命名冲突

```js
// 用来计算组件渲染时间的 HOC
function withRenderTime(WrappedComponent) {
  return class extends React.Component {
    componentDidMount() {
      console.log(
        `${WrappedComponent.name} took ${
          Date.now() - this.startTime
        }ms to render`
      );
    }
    render() {
      this.startTime = Date.now();
      return <WrappedComponent {...this.props} />;
    }
  };
}
function MyComp() {
  return <div>Hello</div>;
}
export default withRenderTime(MyComp);
```

#### HOC 和父子组件的区别

- 组件之间的关系，父子组件是层次关系，HOC 是包裹关系
- 数据传递方式不太一样
  - 父子组件通过 props 实现的，是纵向传递
  - HOC 中，数据传递是通过组件的 props 实现的，HOC 将包裹的组件的 props 传递给新的组件，并可以添加额外的 props
  - HOC 接受一个被包裹的组件作为参数，并返回新的组件，新的组件会将原始组件的 props 传递给被包裹的组件，并可以添加额外的 props，是一种横向传递
- 功能增强方式不同
- 组件的复用性
  - 父子组件是对特定场景的
  - HOC 针对通用场景设计的

### React 中如何进行动画处理，有哪些常用的动画方案

- `React Transition Group`
- `React Spring`: 实现复杂的物理动画效果
- css 动画
- `GreenSock Animation Platform` GSAP, 基于 JavaScript 的动画库

```js
// react-transition-group
import { CSSTransition } from "react-transition-group";
import "./Fade.css"
<CSSTransition
  in={this.state.show}
  timeout={200}
  className="fade"
  unmountOnExit // 当组件隐藏时是否卸载
>
  <div>sadadsf</div>
</CSSTransition>;

// Fade.css
.fade-enter{opacity: 0}
.fade-enter-active {opacity: 1;transition: opacity 300ms ease-in-out;}
.fade-exit {opacity: 1}
.fade-exit-active {opacity: 0;transition: opacity 300ms ease-in-out;}
```

```js
// react-spring
function Scale() {
  const [isScaled, setIsScaled] = React.useState(false);
  const animatedProps = useSpring({
    transform: isScaled ? "scale(1.2)" : "scale(1)",
  });
  return (
    <div>
      <button onClick={() => setIsScaled(!isScaled)}>Toggle Scale</button>
      <animated.div style={animatedProps}>Hello</animated.div>
    </div>
  );
}
```

```js
// GSAP
import gsap from "gsap";
function Fade() {
  const boxRef = useRef(null);
  useEffect(() => {
    const t1 = gsap;
    t1.from(boxRef.current, {
      duration: 1,
      opacity: 0,
      x: -100,
      ease: "power3.out",
    }).to(boxRef.current, {
      duration: 1,
      opacity: 1,
      x: 100,
      ease: "power3.out",
    });
  }, []);
  return (
    <div>
      <div ref={boxRef}>Hello</div>
    </div>
  );
}
```

### 什么是 React 中的错误边界(Error Boundary)，有什么作用

在 React 中，错误边界是一种用于处理组件错误的机制，可以捕获子组件抛出的 JavaScript 错误。

- 一般通过`getDerivedStateFromError()`和`componentDidCatch(error, info)`两个生命周期来捕获
- getDerivedStateFromError 用于更新组件状态
- componentDidCatch 用于记录错误信息和发送错误报告等
- 作用
  - 使应用不会崩溃，而是展示错误信息
  - 更好的处理组件错误，提高程序的健壮性和用户体验

```js
function withErrorBoundary(WrappedComponent) {
  class ErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
      return { hasError: true };
    }

    componentDidCatch(error, info) {
      console.log(error, info);
    }

    render() {
      if (this.state.hasError) {
        return <h1>Something went wrong.</h1>;
      }
      return <WrappedComponent {...this.props} />;
    }
  }

  return ErrorBoundary;
}
function MyComponent(props) {
  if (props.shouldThrowError) {
    throw new Error("Something went wrong.");
  }
  return <div>Hello, World!</div>;
}

const MyComponentWithErrorBoundary = withErrorBoundary(MyComponent);

function App() {
  return (
    <div>
      <MyComponentWithErrorBoundary shouldThrowError={false} />
      <MyComponentWithErrorBoundary shouldThrowError={true} />
    </div>
  );
}
export default App;
```

### React 中如何进行代码分割和懒加载，有哪些常见代码分割方案

#### 代码分割

- ## 使用`import()`函数，webpack 会自动生成一个分离的代码块，并在需要时进行异步加载
- 使用`React.lazy()` React 会自动进行代码分割和懒加载
  - 接收一个返回组件的函数作为参数
  - 会有加载状态和错误处理
- `webpackChunkName`: 在使用`import()`函数时，可以在注释中生成代码块名称

```js
import(
  /* webpackChunkName: "my-chunk" */
  "./MyComp" // my-chunk.hash.js
).then((MyComp) => {
  // do sth
});

// webpack
output {
  filname: "[name].bundle.js",
  chunkFileName: "[name].[chunkhash].js",
}
```

#### 懒加载

- `React.lazy()` 动态加载组件
- `loadable-components` 组件的懒加载和代码分割

```js
import loadable from "@loadable/component";
const MyComp = loadable(() => import("./MyComp"), {
  fallback: <div>Loading</div>,
  onError: (error) => {
    console.log("Error", error);
  },
});
```

### React 是如何进行测试的，有哪些测试方案

- 单元测试
  - Jest 与 Enzyme 或 React Testing Library 结合使用
- 集成测试
  - Cypress 和 Selenium, 模拟用户操作，测试应用程序的整体功能和用户体验
  - 集成测试包括单元测试、组件测试、服务测试，e2e 测试等
- 快照测试
- 性能测试
  - 分析组件性能：React Profiler
  - 优化性能工具：Chrome 开发者工具、Webpack Bundle Analyzer
- 视觉回滚测试

```js
// react 17 和 enzyme 3
// MyComp
import React from "react";
function MyComp(props) {
  const { name } = props;
  return <div>Hello, {name}!</div>;
}

// MyComp.test.js
import { mount, configure } from "enzyme";
import Adapter from "@wojtekmaj/enzyme-adapter-react-17";
import { act } from "react-dom/test-utils"; // 用于模拟React17中的异步渲染
import MyComp from "./MyComp";
configure({
  adapter: new Adapter(),
});
describe("MyComp", () => {
  it("props name 是 111 时", () => {
    const name = "111";
    const wrapper = mount(<MyComp name={name} />);
    expect(wrapper.text()).toBe(`Hello, ${name}!`);
  });
  it("props name 不设置时", () => {
    const wrapper = mount(<MyComp />);
    expect(wrapper.text()).toBe(`Hello, !`);
  });
});
```

#### cypress 集成测试 Demo

```js
// 安装 Cypress
yarn add --dev cypress
yarn add --dev @testing-library/cypress
// 启动 Cypress
npx cypress open // 通过图形界面运行测试用例
npx cypress run // 通过命令行运行测试用例
// 编写测试用例  通常在 cypress/e2e 目录下的 .spec.js文件
describe('Login', () => {
  beforeEach(() => {
    cy.visit('http://localhost:3000/');
  });
  it('successfully log in', () => {
    // cy.visit("/login")
    cy.get('[data-testid=username]').type('username');
    cy.get('[data-testid=login-button]').click();
    // cy.url().should('include', '/dashboard');
    cy.get('[data-testid=welcome-message]').should('contain', 'Welcome, username!');
  });
});

// React代码
function MyComponent() {
  const [username, setUsername] = useState('');
  const handleSubmit = (event) => {
    event.preventDefault();
  };
  const handleUserNameChange = (event) => {
    setUsername(event.target.value);
  };
  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="username">Username</label>
      <input type="text" name="username" value={username} onChange={handleUserNameChange} data-testid="username" />
      <button type="submit" data-testid="login-button"></button>
      <p data-testid="welcome-message">Welcome, {username}!</p>
    </form>
  );
}

// 希望在打包中移除 data-testid属性，可以在package.json文件中添加一下配置
{
  "jest": {
    "globals": {
      "data-testid": true
    }
  }
}
```

```js
import React, { Profiler } from "react";
import List from "./List";
function App() {
  const ListProfiler = withProfiler(List, "List");
  return <ListProfiler />;
}

function withProfiler(WrappedComponent, id) {
  class WithProfiler extends React.Component {
    onRenderCallback(
      id, // 渲染"id", 可以用于识别哪个组件发生渲染
      phase, // 渲染阶段, "mount" 挂载 或 "update" 更新
      actualDuration, // 本次渲染的实际持续时间 毫秒
      baseDuration, // 本次渲染的基准持续时间  ms
      startTime, // 本次渲染的开始时间 ms
      commitTime, // 本次渲染的提交时间
      interactions // 与本次渲染相关的用户交互
    ) {
      console.log(`${id} ${phase} took ${actualDuration} ms`);
    }
    render() {
      return (
        <React.Profiler id={id} onRender={this.onRenderCallback}>
          <WrappedComponent {...this.props} />
        </React.Profiler>
      );
    }
  }
  // 设置高阶组件返回新组件的名字，用于标识组件
  WithProfiler.displayName = `WithProfiler(${
    WrappedComponent.displayName || WrappedComponent.name || "Component"
  })`;
  return WithProfiler;
}
export default withProfiler;
function List() {
  const items = new Array(10000).fill(0).map((_, index) => `Item ${index}`);
  return (
    <ul>
      {items.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  );
}
```

### 什么是 React 中的可持续性，他们有什么作用

- 在 React 中，可持续性是指应用程序的代码、架构和工作流程的可持续性、可扩展性和可维护性
- 可以通过以下几个方面实现 可持续性
  - 代码质量
  - 组织架构
  - 数据管理
  - 工作流程
  - 性能优化
- 使程序更加的可维护、可扩展和可靠

### 什么是 React 中的状态提升，有什么作用

- 状态提升是指组件之间共享状态从子组件中提升到共同的父组件中
- 使程序更加的可靠和可维护
  - 避免重复逻辑
  - 简化代码
  - 提高可维护性
  - 更好的性能

```js
function Father() {
  const [a, setA] = useState("");
  return (
    <>
      <Input1 value={a} change={setA} />
    </>
  );
}
function Input1({ a, setA }) {
  return <input value={a} onChange={setA} />;
}
```

### React 如何重构和优化

- memo 和 PureCompant
- useMemo useCallback
- 懒加载
- 组件最小化
- 用 hook
- 使用虚拟列表或分页
- 提取公共代码

### 什么是 React 中的代码分析和优化，有哪些常用的分析和优化工具

- ESLint: 识别和修复代码问题
- Prettier: 格式化工具
- Webpack Bundle Analyzer: 帮助开发者分析应用程序的打包文件，并识别和解决应用中的性能问题，可以生成可视化分析报告，显示每个模块的大小和依赖关系等信息，从而优化应用程序的打包文件
- Source Map Explorer: 用于分析打包的工具
- React Performance Devtool: 分析 React 组件性能的工具

```js
// 安装 React Performance Devtool
npm install --save-dev react-addons-perf
// 引入
import Perf from "react-addons-perf";
// 组件类添加
import React from 'react';
import Perf from 'react-addons-perf';
const withPerformance = (WrappedComponent) => {
  class WithPerformance extends React.Component {
    componentDidMount() {
      Perf.start(); // 开始性能分析
    }
    componentDidUpdate() {
      Perf.stop(); // 停止性能分析
      const measurements = Perf.getLastMeasurements(); // 获取性能分析结果
      Perf.printWasted(measurements); // 打印浪费的时间
    }
    render() {
      return <WrappedComponent {...this.props} />;
    }
  }
  return WithPerformance;
};
export default withPerformance;
```

### i18n 的原理

- 在 i18n 初始化时，通过 resource 加兹安语言文件和通过 lng 设置默认语言
- useTranslation 钩子获取 i18n 对象
- 通过`t`函数获取翻译后的文本

### 函数式组件的优点

- 代码量少
- 可读性好
- 方便测试
- 性能好：纯函数，可以更好的利用 React 的渲染优化机制，提高组件性能

### React 动态加载的方案

- `React.lazy()`和`Suspense`
- `React Loadable`: 更加细粒度的控制组件加载行为
- webpack 导入`import()`

```js
// loadable
const LoadableMyComponent = Loadable({
  loader: () => import("./MyComponent"),
  loading: () => <div>Loading...</div>,
});
// webpack
useEffect(() => {
  import("./MyComponent").then((module) => setMyComponent(module.default));
}, []);
```

### React 中的数据缓存

- 避免重复计算
  - 将计算结果缓存到组件的 state 或 ref 或 Context 中
- 避免重复请求
- 提高用户体验

## 时间分片技术

- JavaScript 时间切片是指将一个长时间运行的任务分解成多个小任务，并将这些小任务分配到不同的事件循环中执行，从而避免阻塞主线程，并提高应用程序的性能和用户体验。api: `requestIdleCallback`
- React18 引入了渐进式渲染的特性，使用时间分片来实现异步渲染

```js
function doSomeWork() {
  // 执行一些计算密集型任务或 I/O 密集型任务
}
function scheduleWork() {
  requestIdleCallback((deadline) => {
    while (deadline.timeRemaining() > 0) {
      // 空闲时间执行一些任务
      doSomeWork();
    }
    if (还有任务需要执行) {
      scheduleWork();
    }
  });
}
scheduleWork();
// 兼容可以使用polyfill或垫片来模拟requestIdleCallback API
if (!window.requestIdleCallback) {
  window.requestIdleCallback = function (callback) {
    var start = Date.now();
    return setTimeout(function () {
      callback({
        didTimeout: false,
        timeRemaining: function () {
          return Math.max(0, 50 - (Date.now() - start));
        },
      });
    });
  };
}
if (!window.cancelIdleCallback) {
  window.cancelIdleCallback = function (id) {
    clearTimeout(id);
  };
}
```

### React18 的渐进式渲染

- Scheduler
  - 调度器，用于分配任务和调度任务的执行顺序
- Concurrent Mode
  - 渐进式渲染
- Suspense
  - 实现异步渲染和数据加载
- useTransition
  - 实现过度动画和渐进式渲染

```js
// useTransition
function AsyncButton(props) {
  const { onClick, children, ...rest } = props;
  const [startTransition, isPending] = useTransition({
    timeoutMs: 3000,
  });
  function handleClick(event) {
    startTransition(() => {
      if (onCliick) {
        onClick(event);
      }
    });
  }
  return (
    <button {...rest} onClick={handleClick}>
      {children}
      {isPending && <span>Loading...</span>}
    </button>
  );
}
// Scheduler
// 使用的是 requestIdleCallback 或 postMessage API 来调度任务
// 调度器本身性能开销
// 分解任务的开销
import { Scheduler, unstatble_runWithPriority } from "react-scheduler";
function handleClick(event) {
  Scheduler.scheduleCallback(unstatble_runWithPriority.bind(null, callback));
}

// Concurrent Mode
function fetchData() {
  // 使用 <React.unstable_AsyncMode> 组件将渲染过程分解成多个小任务
  return (
    <React.unstable_AsyncMode>
      <div>{fetchDataTask()}</div>
    </React.unstable_AsyncMode>
  );
}
function fetchDataTask() {
  fetch("/api/data")
    .then((response) => response.json())
    .then((data) => {
      setData(data);
    });
}
<React.unstable_ConcurrentMode>
  <button onClick={fetchData}></button>
</React.unstable_ConcurrentMode>;
```

## node.js 项目的依赖包不能用于 web，可以用`nodeExternals`来排除

```js
const nodeExternals = require("webpack-node-externals");
module.exports = {
  // 添加以下选项
  resolve: {
    alias: {
      // 将 "my-node-library" 替换为 Web 可用的版本
      "my-node-library": path.resolve(
        __dirname,
        "path/to/web/version/of/my-node-library"
      ),
    },
  },
  target: "node",
  externals: [nodeExternals()],
};
```

## 如何优化 web 页面的性能

- 压缩资源
- 缓存数据
- 减少 HTTP 请求
- 图片优化
- 使用 CDN（内容分发网络）
- 延迟加载
- 去除不必要的代码
- 使用缓存技术
- 使用 WebWorkers（postMessage）
- 使用优化的 JavaScript，使用代码分离技术、懒加载和异步加载等

## JavaScript 是如何监听 URL 变化的

- window 对象上的 hashchange 或 popstate
  - 当 URL 发生变化时，浏览器会触发 hashchange
  - 当用户通过浏览器前进或后退按钮导航到不同页面时，会触发 popstate
  - 用`history.pushState()`或`history.replaceState()`来修改浏览器的历史记录，从而触发 popstate 事件

```js
window.addEventListener("hashchange", function () {
  console.log("URL hash changed!");
});
window.addEventListener("popstate", function () {
  console.log("URL hash popstate!");
});
history.pushState({ page: 1 }, "title1", "/page1");
history.replaceState({ page: 3 }, "title3", "/page3");
```

## this 的指向

- 普通函数，this 指向是在函数被调用的时候确定的，谁调用指向谁
- 箭头函数，this 的指向是在函数定义的时候确定的

## ES6 新特性

- 变量申明
- 对象属性简写
- Object.assign 对象合并
- 解构赋值
- 展开运算符`...`
- 模板字符串
- Promise
- import 和 export

```js
const a = { a: 1 };
const b = { b: 1 };
const c = Object.assign(a, b);
// 解构
const { a, b } = c;
```

## babel

```js
module.exports = {
  // 预设
  presets: ["module:metro-react-native-babel-preset"],
  plugins: [
    [
      // 模块解析
      "moule-resolver",
      {
        root: ["./src/"],
        alias: {
          "@utils": "./src/utils",
        },
      },
    ],
  ],
  env: {
    production: {
      // 生成环境下把console给关掉
      plugins: ["transform-remove-console"],
    },
  },
};
```

## ts 中的交叉类型怎么实现

```ts
interface A {
  a: string;
  b: string;
  c: boolean;
}
// Omit 剔除A里的 a和b两个属性
interface B extends Omit<A, "a"|"b"> {
  d: Date;
}
const b: B{
  c: true,
  d: new Date()
}
```
