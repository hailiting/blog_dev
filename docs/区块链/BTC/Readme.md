# BTC

`Bitcoin Core` 比特币 app

## 公钥和地址

### 公私钥

- 私钥的本质是一个随机数，在 $2^{256}$ 随机的选择出来
  - 用一个可信的随机数产生一个比 256 位更大一些的字符串，然后放入到安全的 SHA256 哈希函数中，产生这个 256 位的数据可以被认为是一个随机数（椭圆曲线的算法）

### 压缩公钥

- 最早的公钥是 65 字节，但因为公钥是在$y^2 mod p = (x^3+7) mod p$曲线上的点(x, y)，因此只需要保存 x 的值，通过私钥可以计算出来 y 的值，这样可以降低将近 50%存储空间（另外需要保存 y 的正负）

### 地址

- 早期 BTC 软件支持将 IP 地址作为收款地址，但后来因为需要保持在线、隐私和 NAT 映射的问题等，这个功能被移除掉了，P2PK 一样也没有大规模使用过

#### P2PKH 与 P2SH

- P2PKH 和 P2SH 是仅有的 2 个使用`base58check`编码地址（脚本模板），目前主要都改用为 bech32 地址
  - P2PKH：把公钥先 SHA256，然后 RIPEMD-160

##### Bech32 和 Bech32m

|                 | bech32        | bech32m                       |
| --------------- | ------------- | ----------------------------- |
| Witness Version | bc1q          | bc1p                          |
| Witness Program | 20 或 32 字节 | 32 字节(但未来可能是其他长度) |
| checksum        | 6 字节        | 6 字节                        |

### 压缩私钥

- 私钥本身是$2^{256}$的随机数，所以没办法压缩，压缩私钥是指导从压缩私钥导出压缩公钥
- 压缩私钥的长度会比普通私钥(WIF)多一个字节，用来表示压缩公钥的 y 值正负

| 格式           | 固定前缀 | 格式                    |
| -------------- | -------- | ----------------------- |
| 16 机制        | 无固定   | 64 位长度 16 进制的数字 |
| WIF            | 5        | Base58                  |
| WIF-compressed | K 或 L   | 添加 0x01 1 字节的后缀  |

## 钱包恢复

- 确定性秘钥生成以及 BIP32
  - key tweek 在主密钥上加上一个数字，生成一个新的密钥
- 种子、助记词和口令短语
  - BIP39: 12-24 个单词
  - Electrum V2
  - Aezeed: LND 在使用的，对 BIP39 进行改进
  - Muun
  - SLI39: BIP39 同批作者的后续方案，对一个种子可以有多份助记词（例如生成 5 份助记词，但只需要其中 3 份就可以恢复出种子）
  - 新方案：例如 Codex32，可最多 32 份助记词
- 可令短语
  - 可令短语（paddphrase）可以与助记词（recovery code）同事使用，这在 BIP39、Electrum v2、Aezeed、SLIP39 中都支持
  - 口令短语会导致生成一个种子，进而形成不同的 BIP32 树
- 非密钥数据备份
  - BIP329
- 派生路径备份

  - 标准派生路径

  | 标准  | 脚本          | BIP32 路径  |
  | ----- | ------------- | ----------- |
  | BIP44 | P2PKH         | m/44'/0'/0' |
  | BIP49 | Nested P2WPKH | m/49'/1'/0' |
  | BIP84 | P2WPKH        | m/84'/0'/0' |
  | BIP86 | P2TR 单秘钥   | m/86'/0'/0' |

  - 显示路径

- 索引规则和路径
  - 索引数字规则
    - 普通派生: 从 0 到 $2^{32}-1$
    - 强化派生: 从 $2^{31}$ 到 $2^{32}-1$, 用`i'`形式表示
    - 主秘钥中也跟随密码学上的惯例
      - m 表示从主私钥派生出来的私钥
      - M 表示从主公钥派生出来的公钥
    - 子密钥可以无限、任意的生成
      - BIP43: 规定第一级表示`purpose` 目的
      - BIP44: 设置了 5 级路径: `m/purpose'/coin_type'/account'/change/address_index`
        - `purpose'`: 44'
        - `coin_type'`： 0' 主网 1' 测试网
        - `account'`: 用户可以开始设设置账户，强化地址
        - `change`: 找零地址
        - `address_index`: 每次使用的账户地址

## Transactions 交易

### 版本

- v2: 涉及到一次共识机制的升级 - BIP68(对一个 opcode OP_CHECKSEQUENCEVERIFY 的含义做了修改，改为 RBF 和相对时间锁)

### 输入

序列号(Sequence)字段

- sequence < $2^{32}-1$：允许 RBF
- 另外 0 < sequence < $2^{32}-1$ 有一个时间锁

### 输出

- 金额
- 输出脚本

### UTXO 和 UTXO 集

- 有输出后，这笔交易未花费前就是一个 UTXO，需要保存
- 如果有了粉尘攻击或铭文之后，UTXO 集会很大，所以还有一种解决办法就是 Utreexo，一般节点只保存一个 UTXO 集的承诺。但仍然需要某些节点保存全部 UTXO 数据
- 脚本中有一个特例：`OP_RETURN`，不可花费（一般都是 0 金额），所以也就不用占用 UTXO 集。一般用来携带数据。

### 交易延展性

- 是指比特币交易的签名可以被更改，而这种更改并不会使交易失效，但却会改变交易的哈希值（TxID）
- 解决方案
  - 隔离见证(SegregatedWitness, SegWit)：通过分离交易签名数据(Witness)来减少延展性，使得交易哈希只依赖于交易的核心数据，从而降级延展性攻击的影响
  - BIP 62：标准化交易的序列化格式
  - 二次交易确认
  - 零确认交易的代替：闪电网络等二层

### 隔离见证

- 输入脚本里的某项数据是只有接收者才知道的

### Coinbase 交易

- 挖矿
  - 输入：null txid(全 0)和最大的输出序号(0xffffffff)
  - 输出：金额是除了挖矿产出外，还包括所有交易的手续费（每笔交易的输入输出差）
  - 100 个区块后才能被花费

### 交易质量和 vbyte

- 交易的手续费定位为：交易重量，或虚拟字节(vbyte, 4 个单位的虚拟字节等于一个实际的字节)
- 隔离见证区域里的数据在计算上是有折扣的

## Authorization 和 Authentication 授权与鉴权

### P2SH

- BIP13 提出的， 将一个脚本哈希作为地址
- 可以算作另一种账户抽象或智能合约的账户实现

### 时间锁

- 绝对时间锁、相对时间锁
- 实现层面包括：交易层面、脚本 opcode 层面
  - 交易层面：sequence 字段
  - 脚本层面：OP_CLTV（绝对时间锁），OP_CSV（相对时间锁）

### P2WPKH 和 P2WSH

segwit v0 版本的见证程序可以包括 P2WPKH、P2WSH

- P2WPKH: 20 个字节，必须压缩公钥 hash 来构造出来
- P2WSH: 32 个字节

### nested P2WPKH 和 nested P2WSH

外表看起来是 P2SH，但实际上是 nested 的地址

### MAST

MAST 可以包含更多的程序内容或条件

- 一组脚本

### P2C

Pay to Contract，BIP32 里提到的派生密钥的一种使用方法

- 实现为某个事项而付款（用地址来表明，而不是公开可知道的 memo）
- 隐私性（双方在没有争议的时候可以不揭露），因为是一个派生出来的新地址
- 例子：Bob 因为某个事项，付款给 Alice
  - Bob 将这个事项变成 Hash，进而转换为一个数字
  - Tweek: Bob 把这个数字加到 Alice 的公钥上，形成一个新的公钥
  - 对应这个公钥的私钥，只有 Alice 可用他的私钥来生成

### Taproot

和 P2C 略有不同，tweek 用的 hash 是对一个程序代码的承诺，承诺的方式是对 Mast 的树根

- keypath 花费
  - 只用到单签，或无脚本多签
  - 最终要上链的包括
    - witness program: 公钥
    - witness structure: 签名
- keyscript 花费
  - 使用到一个脚本树
  - 最终要上链的包括
    - witness program: 公钥
    - witness structure: 版本号、潜在要用到的密钥（称为：taproot internal key）、执行脚本（称为：leaf script）、从树根到叶子路径上的每个树分叉处的 hash、其他脚本需要的数据（如：签名、hash 原像等）

### Tapscript

Taproot 使用的和比特币脚本里的略微有些区别，因此被称为 tapscript

- 去掉了 OP_CHECKMULTISIG 和 OP_CHECKMULTISIGVERIFY，因为和 schnorr 签名批量验证的方式没法很好的结合；对应的，添加 OP_CHECKSIGADD，成功验证一个签名就加一，用来数有多少个签名通过校验
- 所有在 tapscript 里的签名都用 schnorr 签名（BIP340）
- OP_SUCCESSx opcode, 重新定义了一些之前的 opcode, 并认为是执行结构成功（这样以后还可以通过软分叉方式将其定义为在某些条件下失败，但如果反过来则很难，需要硬分叉）
