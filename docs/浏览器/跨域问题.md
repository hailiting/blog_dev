# 跨域
网络攻防包括：
  CSRF(跨站请求伪造攻击)，XSS(跨站脚步攻击)，SQL注入，cookie拦截修改
## 表现形式
1，接口403
2，cor跨域
## 产生问题的原因
### 网络域和浏览器的同源策略
#### 什么是同源策略
1，协议相同
2，域名相同
3，端口相同
三者同时成立叫同源，
从域名A下的一个页面（一般是通过ajax请求）获取域名B下的一个资源，是不被浏览器容许的。
跨域有四个点要满足：
1，A和B不同源
2，同源策略是浏览器做的限制（所以APP永远不会跨域）
3，从H5发送的请求，经过浏览器
4，跨域的意思是：浏览器还是会发送请求，但浏览器会拦截响应内容，如果发现响应header中有"Access-Control-Allow-Origin"设置的容许访问源没有包含当前源，则拒绝将数据返回给当前源（可以设置值为 * ）
ep: <img> <script> <style><link> 等标签里有src是不做同源限制的
## 绕过同源策略的四种方案
### 1, 服务器做设置，即响应头添加"Access-Control-Allow-Origin",指定容许访问的源
~~~
@PostMapping "/account/login";
@ResponseBody
public ResulttModel<String> login
  HttpServietResponse response,
  HttpServietRequest request,
  @RequestParam String useId,
  @RequesstParam String password
  // response.setHeader("Access-Control-Allow-Origin", "*");
  return this.accountService.login response,userId, password;
~~~
### 2, document.domain
~~~
var w=window.open("http://www.qq.com");
w.document;
// Uncaught DOMException: Blocked a frame with origin "http://id.qq.com" from accessing a cross-origin frame.

// 设置document.domain
document.domain = 'qq.com';
w.document;
  // success
~~~
### 3，利用<script>不受限制的设定，通过把不同源的请求伪装成一个脚本请求，服务器端返回数据后，脚本会自动回调，这就是所谓的JSONP跨域。
### 4，服务器代理，正向代理与反向代理
正向代理：与页面同源的服务器代你向不同源的服务器请求数据并转发到页面
反向代理：使用nginx地址映射（a请求b，a的服务器上虚拟出服务c,其实c只是表面上和a同源，真正的映射到到b，a实际上是向b请求）