# 跨域
网络攻防包括：
  CSRF(跨站请求伪造攻击)，XSS(跨站脚步攻击)，SQL注入，cookie拦截修改
## 表现形式
1，接口403
2，cor跨域
## 产生问题的原因
### 网络域和浏览器的同源策略
#### 什么是同源策略
1，协议相同
2，域名相同
3，端口相同
三者同时成立叫同源，
从域名A下的一个页面（一般是通过ajax请求）获取域名B下的一个资源，是不被浏览器容许的。
跨域有四个点要满足：
1，A和B不同源
2，同源策略是浏览器做的限制（所以APP永远不会跨域）
3，从H5发送的请求，经过浏览器
4，跨域的意思是：浏览器还是会发送请求，但浏览器会拦截响应内容，如果发现响应header中有"Access-Control-Allow-Origin"设置的容许访问源没有包含当前源，则拒绝将数据返回给当前源（可以设置值为 * ）
ep: <img> <script> <style><link> 等标签里有src是不做同源限制的
## 绕过同源策略的多种方式
### 1 服务器做设置，即响应头添加"Access-Control-Allow-Origin",指定容许访问的源
~~~
@PostMapping "/account/login";
@ResponseBody
public ResulttModel<String> login
  HttpServietResponse response,
  HttpServietRequest request,
  @RequestParam String useId,
  @RequesstParam String password
  // response.setHeader("Access-Control-Allow-Origin", "*");
  return this.accountService.login response,userId, password;
~~~
### 2 document.domain
~~~
var w=window.open("http://www.qq.com");
w.document;
// Uncaught DOMException: Blocked a frame with origin "http://id.qq.com" from accessing a cross-origin frame.

// 设置document.domain
document.domain = 'qq.com';
w.document;
  // success
~~~
### 3 利用<script>不受限制的设定，通过把不同源的请求伪装成一个脚本请求，服务器端返回数据后，脚本会自动回调，这就是所谓的JSONP跨域。
~~~
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function jsonp({url, params, callback}){
        return new Promise((resolve, reject)=>{
          let script = document.createElement("script");
          window[callback] = function(data){
            resolve(data)
            document.body.removeChild(script);
          }
          params = { ...params, callback } 
          let arrs = []
          for(let key in params){
            arrs.push(`${key}=${params[key]}`)
          }
          script.src=`${url}?${arrs.join("&")}`
          document.body.appendChild(script)
        })
      }
      jsonp({
        url: "http://localhost:3000/say",
        params: {wd:"iloveyou"},
        callback: "show",
      }).then(data=>{
        console.log(data)
      })
    </script>
  </body>
</html>
// node服务
let express = require("express");
let app = express();
app.get("/say", function(req, res){
  let {wd, callback} = req.query;
  console.log(wd);
  console.log(callback);
  res.end(`${callback}("我不爱你")`);
})
app.listen(3000);
~~~
### 4 服务器代理，正向代理与反向代理
正向代理：与页面同源的服务器代你向不同源的服务器请求数据并转发到页面
反向代理：使用nginx地址映射（a请求b，a的服务器上虚拟出服务c,其实c只是表面上和a同源，真正的映射到到b，a实际上是向b请求）
### 5 CORS 跨域资源共享（Cross-origin resource sharing）
实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以跨域通信。
需要注意的是，CORS解决跨域的话，Content-Type 的值不属于下列之一：
* ``application/x-www-form-urlencoded``
* ``multipart/form-data``
* ``text/plain``
~~~
// html
...
<script>
  let xhr = new XMLHttpRequest();
  document.cookie = "name=xiaomin"; // cookie 不能跨域
  xhr.withCredentials = true; // 前端设置是否带cookie
  xhr.open("PUT", "http://localhost:4000/getData", true);
  xhr.setRequestHeader("name","xiaomin");
  xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
      if((xhr.status>=200 && xhr.status <300) || xhr.status === 304){
        console.log(xhr.response)
        console.log(xhr.getResponseHeader("name"))
      }
    }
  }
  xhr.send()
</script>
...
// node  js server1.js
// 设置白名单
let express = require("express");
let app = express();
app.use(express.static(__dirname));
app.listen(3000);


// node js  server2.js
let express = require("express")
let app = express();
let whiteList=["http://localhost:3000"] // 设置白名单
app.use(function(req, res, next){
  let origin = req.headers.origin;
  if(whiteList.includes(origin)){
    // 设置哪个源可以访问我
    res.setHeader("Access-Control-Allow-Origin", origin);
    // 允许哪个头访问我
    res.setHeader("Access-Control-Allow-Headers", "name");
    // 允许哪个方法访问我  为避免多次"预检"请求，返回所有支持的方法
    res.setHeader("Access-Control-Allow-Methods", "PUT,GET");
    // 允许携带cookie
    res.setHeader("Access-Control-Allow-Credentials", true);
    // 预检的存活时间 单位是秒 容许缓存该条回应xxs，在此期间，不用发出另一条预检请求
    res.setHeader("Access-Control-Max-Age", 6);
    // 允许返回头
    res.setHeader("Access-Control-Expose-Headers", "name");
    if(req.method === "OPTIONS"){
      res.end();
    }
  }
  next();
})
app.put("/getData", function(req, res){
  console.log(req.headers);
  res.setHeader("name", "jw");
  res.end("我不爱你瞭")
})
app.get("/getData", function(req, res){
  console.log(req.header);
  res.end("dodo 不爱");
})
app.use(express.static(__dirname))
app.listen(4000)
~~~

### 6 window.postMessage()
~~~
// A窗口<http://example.com:8080> 
...
<script>
  // 弹出框
  var popup = window.open(...popup details ...);
  popup.possMessage
</script>
...
~~~
