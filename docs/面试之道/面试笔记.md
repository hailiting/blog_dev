# 面试笔记

## - pg01

```js
+(function() {
  alert(a); // 1. function a(){alert(2)}
  a();
  var a = function() {
    alert(1); // 4. 1
  };
  function a() {
    alert(2); // 2. 2
  }
  alert(a); // 3. function (){alert(1)}
  a();
  var d = a;
  var c = d; // error
})();
alert(d); //erroe
alert(c);
```

考点：

- 1. IIFE->匿名自执行函数，此时创建闭包
- 2. 函数的提升比变量要前
- 3. 作用域和连等问题

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 }; // !=   a={n:2}  a.x=a;   此时的 a 是 undifined变量
alert(a.x); // undefined  1. a={n:2}  2. a.x = a;
alert(b.x); // {n:2}
```

```js
this.a = 20;
var test = {
  a: 40,
  init: () => {
    console.log(this.a);
    function go() {
      console.log(this.a);
    }
    go.prototype.a = 50;
    return go;
  },
};
new (test.init())();
```

考点：

- this 的指向问题，this 只有执行的时候才能确认下来，谁调用，就指向谁，没人调用就指向 window
- 当函数当做构造函数的时候，原型链里 this 对属性的赋值要低于函数内部指向

## - pg2

如何正确输出 li 里的值

```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script type="text/javascript">
  var list_li = document.getElementsByTagName("li");
  for (var i = 0; i < list_li.length; i++) {
    list_li[i].onclick = function() {
      console.log(i);
    };
  }
</script>
```

- 1. 闭包解决：函数作为返回值、函数作为参数传递，保护变量。【内存泄露可以把参数置空】

```js
var list_li = document.getElementsByTagName("li");
for (var i = 0; i < list_li.length; i++) {
  list_li[i].onclick = (function(i) {
    return function() {
      console.log(i);
    };
    i = null;
  })(i);
}
```

- 2. 块级作用域和全局作用域，使用 let

```js
var list_li = document.getElementsByTagName("li");
for (let i = 0; i < list_li.length; i++) {
  list_li[i].onclick = function() {
    console.log(i);
  };
}
```

- 3. this.innerHTML

```js
var list_li = document.getElementsByTagName("li");
for (var i = 0; i < list_li.length; i++) {
  list_li[i].onclick = function() {
    console.log(this.innerHTML);
  };
}
```
