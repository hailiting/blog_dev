(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{736:function(n,s,t){"use strict";t.r(s);var e=t(44),a=Object(e.a)({},(function(){var n=this,s=n.$createElement,t=n._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"nginx-的反向代理与负载均衡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx-的反向代理与负载均衡"}},[n._v("#")]),n._v(" nginx 的反向代理与负载均衡")]),n._v(" "),t("h2",{attrs:{id:"正向代理与反向代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正向代理与反向代理"}},[n._v("#")]),n._v(" 正向代理与反向代理")]),n._v(" "),t("h3",{attrs:{id:"正向代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正向代理"}},[n._v("#")]),n._v(" 正向代理")]),n._v(" "),t("p",[n._v("明确知道要访问的地址。用计算机 A 访问某个网站 B,如果是国外的，需要服务器 C 做代理服务器，通过 C 访问 B，这种访问方式就是正向代理。")]),n._v(" "),t("h3",{attrs:{id:"反向代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反向代理"}},[n._v("#")]),n._v(" 反向代理")]),n._v(" "),t("p",[n._v("目标网站有一个服务器集群，并且集群中每个服务器的内容都一样，如果从个人电脑直接访问服务器集群中的服务器，是无法访问的，并且此时第三方服务器可以访问集群，这个时候我们就可以通过第三方服务器访问集群内容，但我们此时不知道是那一台服务器提供的内容，此时的代理方式称为方向代理。\n第三方服务器需要负载均衡，负担服务器压力，保证集群中的每一个服务器压力趋于平衡，避免崩溃情况。\n正向代理的服务对象是客户端，反向代理的对象是服务端。")]),n._v(" "),t("h2",{attrs:{id:"什么是-httpupstream模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-httpupstream模块"}},[n._v("#")]),n._v(" 什么是 HTTP"),t("code",[n._v("Upstream")]),n._v("模块")]),n._v(" "),t("p",[n._v("Upstream 模块实现在轮询和客户端 Ip 之间实现后端的负载均衡。\n常用的指令有： "),t("code",[n._v("ip_hash")]),n._v("、"),t("code",[n._v("server")]),n._v("、"),t("code",[n._v("Upstream")])]),n._v(" "),t("h3",{attrs:{id:"ip-hash命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip-hash命令"}},[n._v("#")]),n._v(" "),t("code",[n._v("ip_hash")]),n._v("命令")]),n._v(" "),t("p",[n._v("权重【默认是 1:1】")]),n._v(" "),t("h3",{attrs:{id:"server指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#server指令"}},[n._v("#")]),n._v(" "),t("code",[n._v("server")]),n._v("指令")]),n._v(" "),t("h3",{attrs:{id:"upstream指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#upstream指令"}},[n._v("#")]),n._v(" "),t("code",[n._v("Upstream")]),n._v("指令")]),n._v(" "),t("h2",{attrs:{id:"部署-nodejs-流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#部署-nodejs-流程"}},[n._v("#")]),n._v(" 部署 NodeJS 流程")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1，下载nginx\nbrew search nginx / brew install nginx\n2, brew info nginx 【会打印本机上nginx信息】\n3, nginx -v 【版本信息】\n4, 指定自己的配置``nginx  -c``\n   sudo nginx  -c /usr/local/etc/nginx/nginx.conf【默认端口为8080】\n    - tips: 如果安装过Jenkins的话，这里会失效\n    - sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n    - systemctl start jenkins\n5, sudo brew services stop nginx/nginx\n6, sudo nginx -s reload、nginx -s stop\n7, 查看nginx配置文件\n8, 查看当前配置文件 nginx -t -c 自己配置的文件地址\n9, 拷贝配置文件至Node项目目录，重新修改\n10,服务器端的nginx地址\n11, ``nginx -t``是否生效\n12, 端口号被占用处理\n// grep node 筛选出含node字眼的进程\nps aux | grep node  // 那个程序在运行 第二位为 pid  然后kill -9 pid\nps -ef | grep node // nginx\nlsof -i tcp:8081  // 端口\n// kill -9 [-9 发一个强制任务的信号-顽固的进程，内核亲自去杀， kill 发一个停止进程的信号]\nkill -9 pid\nssh 用户名@地址\nscp course-map.json root@ip地址:/路径 [scp 文件 name@ipaddress:/path]\nscp -r advance/ root@101.200.185.250:/opt/node-publish/www/static/\nunzip build[解压]\nrm *\n.sh js 执行对应的权限\nmv name01 name02 # 把 name01 改为 name02\n13, npm install --production 只管上线环境\n14, pm2动态监测文件\n  14-1 能够动态监控文件上传，0秒热启动\n  14-2 负载平衡CPU\n  14-3 内存使用过多或cpu调度过于频繁，重启\n  14-4 restart个数\n\n")])])]),t("p",[n._v("找到真正的"),t("code",[n._v(".conf")]),n._v("文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("nginx.conf\nworker_processes 4;\nevents{\n  # 最多的并发连接\n  worker_connections 1024;\n}\nhttp{\n  # upstream 负载均衡的所有server地址\n  upstream firsttest{\n    ip_hash; #落在确定服务器后就不更改了\n    server 111.13.100.92 weight=2; # weight 权重\n    server 111.13.179.253;\n  }\n  server{\n    listen 8080;\n    location / {\n      proxy_pass http://firsttest; #代理访问\n    }\n  }\n}\n")])])])])}),[],!1,null,null,null);s.default=a.exports}}]);