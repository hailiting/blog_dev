(window.webpackJsonp=window.webpackJsonp||[]).push([[263],{682:function(e,n,t){"use strict";t.r(n);var s=t(44),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"前端项目持续集成-一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端项目持续集成-一"}},[e._v("#")]),e._v(" 前端项目持续集成(一)")]),e._v(" "),t("h2",{attrs:{id:"什么是持续集成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是持续集成"}},[e._v("#")]),e._v(" 什么是持续集成")]),e._v(" "),t("h3",{attrs:{id:"百度百科"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#百度百科"}},[e._v("#")]),e._v(" 百度百科")]),e._v(" "),t("ul",[t("li",[e._v("是一种软件开发实践，每个开发人员每天至少要集成一次代码，每次集成都通过自动化构建「包括编译、发布、自动化测试」，从而尽早的发现集成错误。")]),e._v(" "),t("li",[e._v("持续集成一般和持续部署一起被提及【CI/CD】")]),e._v(" "),t("li",[e._v("减少风险")]),e._v(" "),t("li",[e._v("减少重复过程")]),e._v(" "),t("li",[e._v("任何时间任何地点都可部署软件")]),e._v(" "),t("li",[e._v("增强项目的可见性")]),e._v(" "),t("li",[e._v("建立团队对开发产品的信心")])]),e._v(" "),t("ul",[t("li",[e._v("持续集成要遵从的原则\n"),t("ol",[t("li",[e._v("所有开发人员需要在本地机器上做本地构建，在提交版本控制库中，从而确保变更不会导致持续集成失败")]),e._v(" "),t("li",[e._v("开发人员每天至少向版本控制库提交一次代码")]),e._v(" "),t("li",[e._v("开发人员每天至少从版本控制库中更新一次代码到本地机器")]),e._v(" "),t("li",[e._v("需要有专门的集成服务器来执行集成构建，每天要执行多次构建")]),e._v(" "),t("li",[e._v("每次构建都要 100%通过")]),e._v(" "),t("li",[e._v("每次构建都可以生成可发布的产品")]),e._v(" "),t("li",[e._v("修复失败的构建是优先级最高的事情")]),e._v(" "),t("li",[e._v("测试是未来，未来是测试")])])])]),e._v(" "),t("h3",{attrs:{id:"ci-cd-流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd-流程"}},[e._v("#")]),e._v(" CI/CD 流程")]),e._v(" "),t("ol",[t("li",[e._v("本地机器写代码")]),e._v(" "),t("li",[e._v("提交代码，push 到 git 远程仓库")]),e._v(" "),t("li",[e._v("git hook 触发 jenkins 的构建 job(自动)")]),e._v(" "),t("li",[e._v("jenkins job 中拉取项目代码，运行"),t("code",[e._v("npm run unit")]),e._v("和"),t("code",[e._v("npm run build")]),e._v("，如果失败，发邮件通知相关的人。（自动）")]),e._v(" "),t("li",[e._v("jenkins job 中执行测试服务器的部署脚本（自动）")])]),e._v(" "),t("p",[e._v("当代码发生变更到 gitlab 的时候，就可以通过钩子将代码变更事件提交到 CI 系统，CI 系统也就是构建平台，一些插件组成的系统，可以在上面写脚本，这是一个服务器，上面有很多软件，如 jenkins 等(还有一个发布服务器，专门负责发布的)，这台服务器也有引用代码仓库的钩子，检测到一些变更事件后就自动构建部署到内网，自动测试，自动提测。【最在 jenkins 上利用 webpack/grunnt 等进行项目构建并自动化测试，若成功，交付给 QA，若失败，打回开发】")]),e._v(" "),t("h2",{attrs:{id:"前端工程化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化"}},[e._v("#")]),e._v(" 前端工程化")]),e._v(" "),t("h3",{attrs:{id:"自动化编译里都发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动化编译里都发生了什么"}},[e._v("#")]),e._v(" 自动化编译里都发生了什么")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("-> 读取foo.es文件内容，babel编译成js\n-> 分析js内容，找到资源定位标记 foo.scss\n-> 对foo.scss进行编译\n  -> 读取foo.scss的文件内容，编译成css内容\n  -> 分析css内容，找到资源定位标记 url(foo.png)\n  -> 对foo.png进行编译\n    -> 读入foo.png内容\n    -> 图片压缩\n    -> 返回图片内容\n  -> 根据foo.png的最终内容计算md5戳，替换url(foo.png)为url(/static/img/foo_2afob.png)\n  -> 替换完毕所有资源定位标记，对css内容进行压缩\n  -> 返回css内容\n-> 根据foo.css最终内容计算md5戳，替换foo.scss为 /static/scss/foo_base39.css\n-> 替换完毕所有资源定位标记，对js内容进行压缩\n-> 返回js内容\n-> 根据最终的js内容计算md5戳，得到foo.coffee的资源url为 /static/scripts/foo_3fc20.js\n")])])]),t("h3",{attrs:{id:"模块化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[e._v("#")]),e._v(" 模块化")]),e._v(" "),t("p",[e._v("每个文件就是一个模块，有自己的作用域，这个文件里所定义的变量、函数、类都是私有的，CMD 和 AMD 都是 CommonJS 的一种规范实现定义，RequireJS 和 SeaJS 是对应的实践。")]),e._v(" "),t("ol",[t("li",[e._v("AMD=> requirejs（预加载）提前读取并加载\n1.1 AMD 推崇依赖前置"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("define(['dep1', 'dep2'], function(dep1, dep2){\n  // 内部只能使用指定模块\n  return function(){}\n})\n")])])]),e._v("1.2 AMD 对加载的模块是提前读取并加载\n1.3 模块化原理")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件加载/文件运行 顺序： 1.js 2.js 3.js\n// 模块运行 顺序 3.js 2.js 1.js\n// 1.js中 入口用require，其他用define\nrequire(['2.js'], function(A){\n  // A是2.js的返回值\n  // 2.js, 3.js都加载完，才执行1.js的这个回调函数\n})\n// 2.js中\ndefine(['3.js', 'xxx.js'], functionA(B, c){\n  return 2; // 2.js模块的返回值\n})\n// 3.js 中\ndefine([], functionA(){\n  return {} // 3.js的返回值\n})\n// 子模块优先执行，主模块最后执行\n")])])]),t("p",[e._v("1.4 优缺点\n1.4.1 AMD 的依赖是提前声明的，依赖无需静态分析，无论是加载器还是自动化工具都可以直接获取到依赖\n1.4.2 AMD 在代码书写上不怎么友好\n1.4.3 AMD 模块内部与 NodeJS 的 modules 有一点差异")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var onload = function(){\n  clearTimeout(tid);\n}\nif('onload' in script){\n  sript.onload = onload;\n} else {\n  script.onreadystatechange=function(){\n    if(this.readyState === 'load' || this.readyState === 'complete'){\n      onload();\n    }\n  }\n}\n)(script, id);\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("CMD => SeaJS（懒加载）提前读取文件，但在需要在加载\n2.1 CMD 推崇就近依赖\n2.2 CMD 对加载的模块是提前读取并不加载，而是需要时加载（依赖模块 CMD 是延迟执行）\n2.3 加载原理")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// CMD\ndefine(finction(require, exports, module){\n  // 此处如果需要加载某模块，就声明加载\n  var xx = require("xxx");\n})\n')])])]),t("p",[e._v("2.4 模块化原理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 只有define，没有require\n// 1.js\ndefine(function(){\n  var a = require("2.js");\n  console.log(22222);\n  var b = require("4.js")\n})\n// 2.js\ndefine(function(){\n  var b=require("3.js")\n})\n....\n')])])]),t("p",[e._v("先把 require 那部分用正则解析出来，需要什么模块就加载什么模块（先把所需要的包下载下来）。全部加载完之后再执行。先执行主模块 1.js，碰到 require(\"2.js\")就执行 2.js，2.js 中碰到 require('3.js')就执行 3.js...\n2.5 优缺点\n2.5.1 CMD 依赖是就近声明，通过内部 require 方法进行声明。但因为是异步模块，加载器需要加载这些模块，所以模块真正使用前需要提取模块里的所有依赖。\n2.5.2 不能直接压缩，require 局部变量如果替换无法加载资源\n2.5.3 CMD 路径参数不能进行字符串运算（用正则解析）")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("为什么要使用 webpack\n3.1 Webpack 执行 CommonJS 标准，解决了依赖配置和请求流量。\n3.2 对于 Webpack 来讲，万物都可是模块，所有文件都被合并到 JS 中，最终在浏览器。\n3.3 兼容 AMD，CMD\n3.4 js 模块化不仅仅为了提高代码复用性，更是为了让资源文件更合理的进行缓存。")])]),e._v(" "),t("h2",{attrs:{id:"前端开发组件化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端开发组件化"}},[e._v("#")]),e._v(" 前端开发组件化")]),e._v(" "),t("ol",[t("li",[e._v("每一个前端模块都是一个小项目，配合 mock.js 可进行本地开发测试。package.json 是标配，通过 webpack 对环境配置进行本地环境，线上环境的统一编译。")]),e._v(" "),t("li",[e._v("有 page 组装 widget，由 widget 组装 WebComponents(X-TAG)。")]),e._v(" "),t("li",[e._v("能够根据路由快速选择配置 SPA")])]),e._v(" "),t("h3",{attrs:{id:"webcomponents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webcomponents"}},[e._v("#")]),e._v(" WebComponents")]),e._v(" "),t("p",[e._v("WebComponents 标准能够使开发者将 HTML 页面功能封装成 CustomElements（自定义标签），而不需要 React, Vue 等来帮助了。")]),e._v(" "),t("h4",{attrs:{id:"custom-element"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#custom-element"}},[e._v("#")]),e._v(" custom element")]),e._v(" "),t("p",[t("code",[e._v("CustomElemenntRegistry")]),e._v("接口实例用来处理 web 文档中的 custom elements->注册一个 custom element,并返回已注册的信息。")]),e._v(" "),t("h5",{attrs:{id:"customelementregistry-define-方法用来注册一个-custom-element-该方法接受以下参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#customelementregistry-define-方法用来注册一个-custom-element-该方法接受以下参数"}},[e._v("#")]),e._v(" "),t("code",[e._v("CustomElementRegistry.define()")]),e._v("方法用来注册一个 custom element，该方法接受以下参数")]),e._v(" "),t("ul",[t("li",[e._v("表示所创建元素名称符合 DOMString 标准的字符串【custom element 名称不能是一个单词，且其中必须要有短横线】")]),e._v(" "),t("li",[e._v("用于定义元素行为的类")]),e._v(" "),t("li",[e._v("可选参数，一个包含 extends 属性的配置对象，是可选参数，他指定所创建的元素继承自哪个内置元素，可继承任何内置元素。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// main.js\nclass WordCount extends HTMLParagraphElement{\n  constructor(){\n    // 必须首先调用super方法\n    super();\n    // 元素功能写在这\n    // 计算器指向元素父级\n    var wcParent = this.parentNode;\n    function countWords(node){\n      var text = node.innerText || node.textContent;\n      return text.trim().split(/\\s+/g).length;\n    }\n    var count = "Words: "+countWords(wcParent);\n\n    // 创建一个shadowRoot\n    var shadow = this.attachShadow({mode: "open"});\n    var text = document.createElement("span");\n    text.textContext = count;\n    // 将span 添加到shadow root上\n    shadow.appendChild(text);\n    setInterval(function(){\n      var count = "Words: "+ countWords(wcParent);\n      text.textCountent = count;\n    }, 200)\n\n    this.addEventListener("click", ()=>{\n      alert("hello world");\n    })\n  }\n  // 当custom element首次被插入文档DOM时，被调用\n  connectedCallback(){\n    console.log("load");\n  }\n  // 当custom element从文档删除时，被调用\n  disconnectedCallback(){};\n  // 当custom element被移动到新文档时，被调用\n  adoptedCallback(){}\n  // 当customelement增加、删除、修改自身属性时，被调用\n  attributeChangedCallback(){}\n}\ncustomElements.define("word-count", WordCount, {extends: "p"});\n// index.html\n...\n<p>weeee</p>\n<p>weeee</p>\n<p is="word-count">1111</word-count>\n...\n')])])]),t("h4",{attrs:{id:"共有两种-customelements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共有两种-customelements"}},[e._v("#")]),e._v(" 共有两种 customElements")]),e._v(" "),t("ul",[t("li",[e._v("Autonomous custom elements 是独立的元素，它不继承其他内建的 HTML 元素，可以直接写成 HTML 标签形式，在页面上用如"),t("code",[e._v("<popup-info>")]),e._v("，或者"),t("code",[e._v('document.createElement("popup-info")')]),e._v("这样。")]),e._v(" "),t("li",[e._v("Customized built-in elementts 继承自基本的 HTML 元素，在创建时，需要制定扩展元素，如上面例子的"),t("code",[e._v("<p>")]),e._v("元素，使用时，用"),t("code",[e._v("is")]),e._v("属性指定 custom element 的名称，例如"),t("code",[e._v('<p is="word-count">')]),e._v("或"),t("code",[e._v('document.createElement("p", {is: "word-count"})')]),e._v("\ntips: shadow root【实验属性】\n具体看 MDN 文档，会更新")])]),e._v(" "),t("p",[e._v("AST")]),e._v(" "),t("p",[e._v("js 堵塞\nMVC\nesjs\nrouter")]),e._v(" "),t("p",[e._v("支持 MVC （MVVM 双向数据绑定）\n沙箱环境")]),e._v(" "),t("p",[e._v("Web Components")]),e._v(" "),t("p",[e._v("Custom Elements\nHtml Imports\nHtml Templates\nShadow Dom")]),e._v(" "),t("p",[e._v("X-Tag")])])}),[],!1,null,null,null);n.default=a.exports}}]);