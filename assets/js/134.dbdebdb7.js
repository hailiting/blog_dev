(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{536:function(a,e,t){"use strict";t.r(e);var r=t(44),s=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"浅拷贝与深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝与深拷贝"}},[a._v("#")]),a._v(" 浅拷贝与深拷贝")]),a._v(" "),t("h2",{attrs:{id:"数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),t("p",[a._v("数据可分为基本数据类型和引用数据类型")]),a._v(" "),t("ul",[t("li",[a._v("栈：基本数据类型（Undefined, Null, Boolean, Number, String），直接存储在栈中的数据")]),a._v(" "),t("li",[a._v("堆：引用数据类型（对象、数组、函数），在栈中的存储指针，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。")])]),a._v(" "),t("p",[a._v("基本数据类型：占据的空间小，大小固定，频繁被使用的数据，所以存储在栈中\n引用数据类型：占据的空间大，大小不固定")]),a._v(" "),t("h2",{attrs:{id:"浅拷贝与深拷贝-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝与深拷贝-2"}},[a._v("#")]),a._v(" 浅拷贝与深拷贝")]),a._v(" "),t("p",[a._v("浅拷贝与深拷贝只针对引用数据类型(array, object, function)")]),a._v(" "),t("blockquote",[t("p",[a._v("浅拷贝只复制指向的某个指针， 而不复制对象本身，新旧对象共享一个内存\n深拷贝会创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会改到原对象(指针指向不同堆地址)")])]),a._v(" "),t("h3",{attrs:{id:"赋值和浅拷贝的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#赋值和浅拷贝的区别"}},[a._v("#")]),a._v(" 赋值和浅拷贝的区别")]),a._v(" "),t("ul",[t("li",[a._v("当把一个对象赋值给一个新的对象时，赋的是栈中的地址，而不是堆中的数据。也就是两个对象指向同一个存储空间，即无论哪一个改变，存储空间的值会改变，两个对象是联动的")]),a._v(" "),t("li",[a._v("浅拷贝是按位拷贝对象，它会创建一个新的对象，这个对象有原对象属性值的精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是存储地址（引用类型）,则拷贝的是引用地址。因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝改造函数只是对对象进行浅拷贝复制（逐个成员依次拷贝），即只复制对象空间而不复制资源")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var obj1={\n  "name": "hai",\n  "age": 18,\n  "language": [1, [2,3], 4]\n}\nvar obj3 = shallowCopy(obj1);\nobj3.name="lisa";\nobj3.language[1]= 5;\nfunction shallowCopy(src){\n  var dis={};\n  for(var key in src){\n    if(src.hasOwnProperty(key)){\n      dis[key] = src[key]\n    }\n  }\n  return dis;\n}\nconsole.log({obj1})\nconsole.log({obj3})\n// obj1 name 未变，language受obj3影响改变了\n')])])]),t("h3",{attrs:{id:"浅拷贝的实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝的实现方式"}},[a._v("#")]),a._v(" 浅拷贝的实现方式")]),a._v(" "),t("h4",{attrs:{id:"_1-object-assign-当-object-只改变一层的时候是深拷贝-其他时候是浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-object-assign-当-object-只改变一层的时候是深拷贝-其他时候是浅拷贝"}},[a._v("#")]),a._v(" 1 Object.assign()[当 object 只改变一层的时候是深拷贝，其他时候是浅拷贝]")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('let obj={\n  username: "koko"\n};\nlet obj2 = Object.assign({}, obj);\nobj2.username = "baba";\nconsole.log(obj) // {username: "koko"}\nlet obj0 = {a: {username: "koko"}}\nlet obj02 = Object.assign({}, obj0);\nobj02.a.username = "kaka";\nconsole.log(obj0) // {a: {username: "kaka"}}\n')])])]),t("h4",{attrs:{id:"_2-array-prototype-concat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-array-prototype-concat"}},[a._v("#")]),a._v(" 2 Array.prototype.concat()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('let arr =  [1,2,{name: "koba"}];\nlet arr2 = arr.concat();\narr2[2].name = "coco";\nconsole.log(arr) // [1,2,{name: "coco"}];\n')])])]),t("h4",{attrs:{id:"_3-array-prototype-slice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-array-prototype-slice"}},[a._v("#")]),a._v(" 3 Array.prototype.slice()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('let arr =  [1,2,{name: "koba"}];\nlet arr2 = arr.slice();\narr2[1] = 44;\nconsole.log(arr) // [1,2,{name: "koba"}] 原数组不变\n// arr2[2].name = "coco"; // 原数组会改变\n// console.log(arr) // [1,2,{name: "coco"}];\n')])])]),t("h3",{attrs:{id:"深拷贝方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝方法"}},[a._v("#")]),a._v(" 深拷贝方法")]),a._v(" "),t("h4",{attrs:{id:"_1-josn-parse-json-stringify-obj-【不能成立函数】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-josn-parse-json-stringify-obj-【不能成立函数】"}},[a._v("#")]),a._v(" 1 JOSN.parse(JSON.stringify(obj)) 【不能成立函数】")]),a._v(" "),t("p",[a._v("json 变字符串，字符串变 json，新的对象产生，开辟一个新的栈")]),a._v(" "),t("h4",{attrs:{id:"_2-手写递归方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-手写递归方法"}},[a._v("#")]),a._v(" 2 手写递归方法")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('// 定义检测数据类型的功能函数\nfunction checkedType(target){\n  return Object.prototype.toString.call(target).slice(8, -1)\n}\nfunction clone(target){\n  let result, targetType = checkedType(target);\n  if(targetType === "Object"){\n    result={}\n  } else if(targetType === "Array"){\n    result = []\n  } else {\n    return target\n  }\n  for(let i in target){\n    let value = target[i]\n    if(checkedType(value) === "Object" || checkedType(value) === "Array"){\n      result[i] = clone(value)\n    } else{\n      result[i] = value;\n    }\n  }\n  return result;\n}\n')])])]),t("h4",{attrs:{id:"_3-lodash-函数库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-lodash-函数库"}},[a._v("#")]),a._v(" 3 lodash 函数库")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var _ = require('lodash');\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f); // false\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);