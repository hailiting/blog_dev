(window.webpackJsonp=window.webpackJsonp||[]).push([[284],{704:function(v,_,s){"use strict";s.r(_);var e=s(44),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"css-伪类与伪元素的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-伪类与伪元素的区别"}},[v._v("#")]),v._v(" css 伪类与伪元素的区别")]),v._v(" "),s("h2",{attrs:{id:"昨日回顾"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#昨日回顾"}},[v._v("#")]),v._v(" 昨日回顾：")]),v._v(" "),s("h3",{attrs:{id:"什么闭包-闭包的优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么闭包-闭包的优缺点"}},[v._v("#")]),v._v(" 什么闭包，闭包的优缺点")]),v._v(" "),s("ul",[s("li",[v._v("闭包就是一个函数吐出另一个函数，并且吐出的函数包含父函数变量，吐出的函数就形成了闭包")]),v._v(" "),s("li",[v._v("优点\n"),s("ul",[s("li",[v._v("函数编译时，闭包就缓存到内存中，读取会快")]),v._v(" "),s("li",[v._v("变量形成区块作用域，不会污染到环境")])])]),v._v(" "),s("li",[v._v("缺点\n"),s("ul",[s("li",[v._v("闭包中变量会一直在内存中，无法被垃圾回收机制回收，有可能造成内存溢出")]),v._v(" "),s("li",[v._v("如果闭包函数变量包含的层级过深，读取的时间会相对的加长")]),v._v(" "),s("li",[v._v("有可能会获得意外的值")])])])]),v._v(" "),s("h2",{attrs:{id:"今日解题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#今日解题"}},[v._v("#")]),v._v(" 今日解题")]),v._v(" "),s("h3",{attrs:{id:"伪类-pseudo-classes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#伪类-pseudo-classes"}},[v._v("#")]),v._v(" 伪类(pseudo-classes)")]),v._v(" "),s("ul",[s("li",[v._v("其核心就是用来选择 DOM 树之外的信息，不能够被普通选择器选择的文档之外的元素，用来添加一些选择器的特殊效果。")]),v._v(" "),s("li",[v._v("比如："),s("code",[v._v(":hover")]),v._v(", "),s("code",[v._v(":acive")]),v._v(", "),s("code",[v._v(":visited")]),v._v(", "),s("code",[v._v(":link")]),v._v(", "),s("code",[v._v(":first-child")]),v._v(", "),s("code",[v._v(":focus")]),v._v(", "),s("code",[v._v(":lang")]),v._v("等")]),v._v(" "),s("li",[v._v("由于状态的变化是非静止的，所以元素达到一个特定状态时，它可能得到一个伪类样式，当状态改变时，它会失去这个样式")]),v._v(" "),s("li",[v._v("由此可以看出，它的功能和 class 有些类似，但它是基于文档外的抽象，所以叫伪类")])]),v._v(" "),s("h3",{attrs:{id:"伪元素-pseudo-elements"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#伪元素-pseudo-elements"}},[v._v("#")]),v._v(" 伪元素(pseudo-elements)")]),v._v(" "),s("ul",[s("li",[v._v("DOM 树没有定义的虚拟元素")]),v._v(" "),s("li",[v._v("核心就是需要创建通常不存在于文档中的元素")]),v._v(" "),s("li",[v._v("比如"),s("code",[v._v("::before")]),v._v(", "),s("code",[v._v("::after")]),v._v("，它选择的是元素指定内容，表示选择元素内容的之前或之后内容")]),v._v(" "),s("li",[v._v("伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。用于将特殊的效果添加到某些选择器。")])]),v._v(" "),s("h3",{attrs:{id:"伪类与伪元素的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#伪类与伪元素的区别"}},[v._v("#")]),v._v(" 伪类与伪元素的区别")]),v._v(" "),s("ul",[s("li",[v._v("表示方法\n"),s("ul",[s("li",[v._v('CSS2 中伪类、伪元素都是以单冒号":"表示，CSS2.1 后规定伪类用":",伪元素用"::"表示。')]),v._v(" "),s("li",[v._v("浏览器同样接受 CSS2 时代已经存在的伪元素单冒号“:”的写法，CSS2 之后新增的伪元素（如："),s("code",[v._v("::selection")]),v._v("）则采用双冒号的写法")])])]),v._v(" "),s("li",[v._v("定义不同\n"),s("ul",[s("li",[v._v("伪类：即假的类，可以添加类来达到效果")]),v._v(" "),s("li",[v._v("伪元素：即假的元素，需要通过添加元素才能达到效果")])])])]),v._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),s("ul",[s("li",[v._v("伪类和伪元素都是用来表示文档外的·元素·")]),v._v(" "),s("li",[v._v("伪类和伪元素分别用单冒号和双冒号来表示")]),v._v(" "),s("li",[v._v("伪类和伪元素的区别，关键点在于如果没有伪元素，是否需要添加元素才能达到效果，如果是则是伪元素，反之则为伪类")]),v._v(" "),s("li",[v._v("相同之处\n"),s("ul",[s("li",[v._v("伪类和伪元素都不出现在源文件和 DOM 树中，也就是说在 HTML 源文件中是看不到伪类和伪元素的")])])]),v._v(" "),s("li",[v._v("不同之处\n"),s("ul",[s("li",[v._v("伪类其实是基于普通 DOM 元素而产生的不同状态，他是 DOM 元素的某一特征")]),v._v(" "),s("li",[v._v("伪元素能够创建在 DOM 树中不存在的抽象对象，而这些抽象对象是能够访问到的")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);