(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{420:function(a,t,s){a.exports=s.p+"assets/img/01.206dc287.png"},721:function(a,t,s){"use strict";s.r(t);var v=s(44),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"垃圾回收机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[a._v("#")]),a._v(" 垃圾回收机制")]),a._v(" "),v("p",[a._v("引用计数")]),a._v(" "),v("p",[a._v("广度优先\n栈区")]),a._v(" "),v("p",[a._v("内存泄露\n闭包")]),a._v(" "),v("h2",{attrs:{id:"浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[a._v("#")]),a._v(" 浏览器")]),a._v(" "),v("ul",[v("li",[a._v("浏览器怎样进行垃圾回收")]),a._v(" "),v("li",[a._v("浏览器中不同类型变量的内存都是何时释放")]),a._v(" "),v("li",[a._v("哪些情况会导致内存泄露，如何避免")]),a._v(" "),v("li",[a._v("weakMap weakSet 和 Map Set 有什么区别")])]),a._v(" "),v("h2",{attrs:{id:"什么是垃圾数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾数据"}},[a._v("#")]),a._v(" 什么是垃圾数据")]),a._v(" "),v("p",[v("img",{attrs:{src:s(420),alt:"垃圾回收"}})]),a._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" dog "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\ndog"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("a "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\ndog"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("a "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"b"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),v("p",[a._v("这时候的 Array 就成了不被使用的数据，专业名词叫[不可达]的数据。\n这就需要回收的垃圾数据。")]),a._v(" "),v("h2",{attrs:{id:"垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),v("h5",{attrs:{id:"第一步-标记空间中-可达-值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一步-标记空间中-可达-值"}},[a._v("#")]),a._v(" 第一步："),v("code",[a._v("标记空间中[可达]值")])]),a._v(" "),v("p",[a._v("V8 采用的是可达性(reachability)算法来判断堆中的对象应不应该被回收。\n这个算法的思路是：")]),a._v(" "),v("ul",[v("li",[a._v("从根节点（Root）出发，遍历所有的对象")]),a._v(" "),v("li",[a._v("可以遍历到的对象，是可达的（reachable）")]),a._v(" "),v("li",[a._v("没有被遍历到的对象，是不可达的（unreachable）")])]),a._v(" "),v("p",[a._v("在浏览器环境下，根节点很多，主要包括")]),a._v(" "),v("ul",[v("li",[a._v("全局变量 window，位于每个 iframe 中")]),a._v(" "),v("li",[a._v("文档 DOM 树")]),a._v(" "),v("li",[a._v("存放在栈上的变量")]),a._v(" "),v("li",[a._v("。。。")])]),a._v(" "),v("p",[a._v("这些根节点不是垃圾，不可能被回收")]),a._v(" "),v("h5",{attrs:{id:"第二步-回收-不可达-的值所占据的内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二步-回收-不可达-的值所占据的内存"}},[a._v("#")]),a._v(" 第二步："),v("code",[a._v("回收[不可达]")]),a._v("的值所占据的内存")]),a._v(" "),v("p",[a._v("在所有标记完成之后，统一清理内存中所有不可达对象")]),a._v(" "),v("h5",{attrs:{id:"第三步-做内存整理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第三步-做内存整理"}},[a._v("#")]),a._v(" 第三步：做内存整理")]),a._v(" "),v("ul",[v("li",[a._v("在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫"),v("code",[a._v("内存碎片")])]),a._v(" "),v("li",[a._v("当内存中出现大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况")]),a._v(" "),v("li",[a._v("所以最后一步是整理内存碎片（但这步是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器）")])]),a._v(" "),v("h2",{attrs:{id:"什么时候垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么时候垃圾回收"}},[a._v("#")]),a._v(" 什么时候垃圾回收")]),a._v(" "),v("p",[a._v("浏览器进行垃圾回收的时候，会暂停 JavaScript 脚本，等垃圾回收完毕再继续执行。"),v("br"),a._v("\n对于普通应用，这样没什么问题，但对于 js 游戏、动画对连贯性要求比较高的应用，如果暂停时间很长就会造成页面的卡顿。")]),a._v(" "),v("h3",{attrs:{id:"分代收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分代收集"}},[a._v("#")]),a._v(" 分代收集")]),a._v(" "),v("p",[a._v("浏览器将数据分为两种，一种是"),v("code",[a._v("临时")]),a._v("对象，一种是"),v("code",[a._v("长久")]),a._v("对象。")]),a._v(" "),v("ul",[v("li",[a._v("临时对象\n"),v("ul",[v("li",[a._v("大部分对象在内存中存活的时间很短")]),a._v(" "),v("li",[a._v("比如函数内部声明的变量，或块级作用域中的变量。当函数或代码块执行结束后，作用域中定义的变量就会被销毁。")]),a._v(" "),v("li",[a._v("这类对象很快就会变的不可访问，应该快点回收")])])]),a._v(" "),v("li",[a._v("长久对象\n"),v("ul",[v("li",[a._v("生命周期很长的对象，比如全局的 window、dom、web API 等等")]),a._v(" "),v("li",[a._v("这类对象可以慢点回收")])])])]),a._v(" "),v("p",[a._v("这两种对象对象不同的回收策略，所以，v8 把堆分为新时代和老生代的两个区域。新时代中存放临时对象，老生代中存放持久对象。并且让副垃圾回收器、主垃圾回收器，分别负责新生代和老生代的垃圾回收。")]),a._v(" "),v("h3",{attrs:{id:"主垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[a._v("#")]),a._v(" 主垃圾回收器")]),a._v(" "),v("p",[a._v("负责老生代的垃圾回收，有两个特定")]),a._v(" "),v("ul",[v("li",[v("ol",[v("li",[a._v("对象占用空间大")])])]),a._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[a._v("对象存活时间长")])])])]),a._v(" "),v("p",[a._v("它使用"),v("code",[a._v("标记-清除")]),a._v("的算法执行垃圾回收")]),a._v(" "),v("ul",[v("li",[v("ol",[v("li",[a._v("首先是标记")])])]),a._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[a._v("从一组根元素开始，递归遍历这组根元素")])])]),a._v(" "),v("li",[v("ol",{attrs:{start:"3"}},[v("li",[a._v("在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素可以判断为垃圾数据")])])]),a._v(" "),v("li",[v("ol",{attrs:{start:"4"}},[v("li",[a._v("直接将标记为垃圾的数据清理掉")])])]),a._v(" "),v("li",[v("ol",{attrs:{start:"5"}},[v("li",[a._v("多次标记-清除，会产生大量不连续的内存碎片，需要进行内存整理")])])])]),a._v(" "),v("h3",{attrs:{id:"副垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[a._v("#")]),a._v(" 副垃圾回收器")]),a._v(" "),v("p",[a._v("负责新生代的垃圾回收，一般只支持 1-8M 的容量\n新生代被分为两个区域(semisspace)：一半是对象区域(From)，一半是空闲区域（To）\n新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理")]),a._v(" "),v("ul",[v("li",[a._v("先给对象区域所有垃圾做标记")]),a._v(" "),v("li",[a._v("标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍")]),a._v(" "),v("li",[a._v("副垃圾回收器没有碎片整理，因为空闲区域里此时是有序的，没有碎片，也就是不需要整理了。")]),a._v(" "),v("li",[a._v("复制完成后，对象区域会和空闲区域进行对调，将空闲区域中存活的对象放入对象区域中")]),a._v(" "),v("li",[a._v("因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生代的空闲会被设置的比较小。")]),a._v(" "),v("li",[a._v("是典型的空间换时间的方法")])]),a._v(" "),v("h3",{attrs:{id:"分代收集-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分代收集-2"}},[a._v("#")]),a._v(" 分代收集")]),a._v(" "),v("p",[a._v("将堆分为新生代和老生代，多回收新生代，少回收老生代。-> 这样就减少每次需要遍历的对象，从而减少每次垃圾回收的耗时")]),a._v(" "),v("h4",{attrs:{id:"scavenge-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scavenge-算法"}},[a._v("#")]),a._v(" Scavenge 算法")]),a._v(" "),v("p",[a._v("在分代基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收，在具体实现时主要采用 cheney 算法，cheney 算法是一种采用复制的方法实现垃圾回收算法。")]),a._v(" "),v("h4",{attrs:{id:"marksweep-和-markcompact"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#marksweep-和-markcompact"}},[a._v("#")]),a._v(" markSweep 和 markCompact")]),a._v(" "),v("p",[a._v("老生代使用的方法")]),a._v(" "),v("h3",{attrs:{id:"增量收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#增量收集"}},[a._v("#")]),a._v(" 增量收集")]),a._v(" "),v("p",[a._v("如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间的暂停。所以引擎将垃圾收集工作分为更小的块，每次处理一部分，多次处理。")]),a._v(" "),v("h3",{attrs:{id:"闲时收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闲时收集"}},[a._v("#")]),a._v(" 闲时收集")]),a._v(" "),v("p",[a._v("垃圾收集器只会在 CPU 空间时尝试运行，以减少可能对代码执行的影响。")]),a._v(" "),v("h2",{attrs:{id:"面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[a._v("#")]),a._v(" 面试题")]),a._v(" "),v("ul",[v("li",[a._v("浏览器是怎么进行垃圾回收的\n"),v("ul",[v("li",[a._v("什么是垃圾回收\n"),v("ul",[v("li",[a._v("不在需要的，即是垃圾，全局变量随时可能用到，所以不一定是垃圾")])])]),a._v(" "),v("li",[a._v("如何捡垃圾\n"),v("ul",[v("li",[a._v("从根节点出发，遍历所有对象，可达的不是垃圾，不可达的是垃圾")]),a._v(" "),v("li",[a._v("回收不可达的值所占据的内存")]),a._v(" "),v("li",[a._v("做内存整理")])])]),a._v(" "),v("li",[a._v("什么时候捡垃圾\n"),v("ul",[v("li",[a._v("垃圾回收会暂停浏览器的运行，所以采用分代收集、增量收集、闲时收集的策略")])])])])]),a._v(" "),v("li",[a._v("浏览器中不同类型变量的内存都是何时释放的\n"),v("ul",[v("li",[a._v("JavaScript 中类型：值类型和引用类型\n"),v("ul",[v("li",[a._v("引用类型： 在没有引用之后，V8 自动回收")]),a._v(" "),v("li",[a._v("值类型：\n"),v("ul",[v("li",[a._v("如果处于闭包，要等闭包没有被引用才会被 v8 回收")]),a._v(" "),v("li",[a._v("非闭包的情况下，等待 V8 的新时代的切换的时候回收")])])])])])])]),a._v(" "),v("li",[a._v("哪些情况会造成内存泄露，如何避免\n"),v("ul",[v("li",[a._v("无限制增长的数组")]),a._v(" "),v("li",[a._v("无限制设置属性和值")]),a._v(" "),v("li",[a._v("任何模块内的私有变量和方法均是永驻内存的 a=null")]),a._v(" "),v("li",[a._v("大循环，无 GC（垃圾回收机制）机会")])])]),a._v(" "),v("li",[a._v("weakMap weakSet 和 Map Set 有什么区别\n"),v("ul",[v("li",[a._v("因为是弱引用，所有可以解决内存泄露的问题")]),a._v(" "),v("li",[a._v("weakMap weakSet 的键名所引用对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用")]),a._v(" "),v("li",[a._v("只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存")])])])]),a._v(" "),v("h2",{attrs:{id:"esp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#esp"}},[a._v("#")]),a._v(" ESP")]),a._v(" "),v("p",[a._v("ESP(Extended Stack Pointer)为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针。与之对应的是 EBP(Extended Stack Point)，扩展基指针寄存器，也被称为帧指针寄存器，用于存放函数栈底指针。")]),a._v(" "),v("h2",{attrs:{id:"node"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[a._v("#")]),a._v(" node")]),a._v(" "),v("p",[a._v("node 使用 JavaScript 在服务端操作最大内存对象受到一定限制(堆区)，64 位系统下约为 1.4GB，32 位系统约 0.7GB，新生代 64 位是 32M，32 位是 16M")]),a._v(" "),v("div",{staticClass:"language-shell extra-class"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" node --huge-max-old-generation-size index.js\n")])])]),v("h3",{attrs:{id:"node-内存泄露分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-内存泄露分析"}},[a._v("#")]),a._v(" node 内存泄露分析")]),a._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[a._v("node"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("inspector\nconsole"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sever PID"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" process"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("pid"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nsudo node "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),a._v("inspect app"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("js\ntop "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("pid "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("2322")]),a._v("\n")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);