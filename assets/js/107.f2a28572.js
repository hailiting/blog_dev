(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{509:function(n,e,t){"use strict";t.r(e);var a=t(44),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[n._v("#")]),n._v(" Generator")]),n._v(" "),t("h2",{attrs:{id:"generator-生成器-是-es6-标准引入新的数据类型-一个-generator-看上去像一个函数-但返回多次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator-生成器-是-es6-标准引入新的数据类型-一个-generator-看上去像一个函数-但返回多次"}},[n._v("#")]),n._v(" generator(生成器)是 ES6 标准引入新的数据类型，一个 generator 看上去像一个函数，但返回多次")]),n._v(" "),t("p",[n._v("一个函数的完整代码：调用一个函数，传入参数，返回结果：")]),n._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[n._v("x")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("return")]),n._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("+")]),n._v(" x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("var")]),n._v(" r "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 有return 则return，没return,实际return undefined;")]),n._v("\n")])])]),t("p",[n._v("generator 和函数不同， generator 由"),t("code",[n._v("function*")]),n._v("定义，并且，除了 return，还可以用"),t("code",[n._v("yield")]),n._v("返回多次。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function* foo(x){\n    yield x+1;\n    yield  x+2;\n    return x+x;\n}\nvar f = foo(5);\nconsole.log(f.next()) // {value: 6, done: false}\nconsole.log(f.next()) // {value: 7, done: false}\nconsole.log(f.next()) // {value: 10, done: true}\nconsole.log(f.next()) // {value: undefined, done: true}\n// 婓波那契数列\nfunction* fib(max){\n    var t,\n        a=0,\n        b=1,\n        n=0;\n    while (n<max){\n        yield a;\n        [a,b] = [b,a+b];\n        // console.log(a,b)\n        n++;\n    }\n    return;\n}\nfor (var x of fib(10)){\n    console.log(x)\n}\n")])])]),t("h3",{attrs:{id:"generator-和普通函数相比-有什么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator-和普通函数相比-有什么用"}},[n._v("#")]),n._v(" generator 和普通函数相比，有什么用？")]),n._v(" "),t("p",[n._v("1，是一个可以记住执行状态函数\n2，把异步回调代码变为‘同步’代")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("try{\n    r1 = yield ajax('api/url1', data1);\n    r2 = yield ajax('api/url2', data2);\n    r3 = yield ajax('api/url3', data3);\n    success(r3)\n} catch(err){\n    console.log(err)\n    handle(err)\n}\n\n\nfunction* next_id(k){\n    let id = 0;\n    for(;;){\n        if(id<k){\n            yield ++id\n        } else{\n            return\n        }\n    }\n}\nfor(var x of next_id(10)){\n    console.log(x)\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 初始化任务\nfunction init({sliceList, callback}){\n    if(!isFunction(callback)){\n        console.log('callback必传，并为function');\n        return;\n    }\n    // 添加切片队列\n    this.generator = this.sliceQueue({\n        sliceList,\n        callback // 用来通知切片的位置\n    })\n    // 开始切片\n    this.next();\n}\n// 切片队列\nfunction* sliceQueue({sliceList, callback}){\n    let listOrNum = (isNum(sliceList) && sliceList) || (isArray(sliceList) && sliceList.length);\n    for(let i=0;i<listOrNum; ++i){\n        const start = performance.now();\n        callback(i);\n        while (performance.now()-start<16.7){\n            yield;\n        }\n    }\n}\nfunction next(){\n    const {generator} = this;\n    const start = performance.now();\n    let res = null;\n    do{\n        res=generator.next();\n    } while(!res.done && performance.now()-start<16.7);\n    if(res.done) return;\n    raf(this.next.bind(this))\n}\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);