(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{715:function(a,t,s){"use strict";s.r(t);var r=s(44),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"请解释-jsonp-的工作原理-以及为什么不是-ajax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请解释-jsonp-的工作原理-以及为什么不是-ajax"}},[a._v("#")]),a._v(" 请解释 jsonp 的工作原理，以及为什么不是 ajax")]),a._v(" "),s("p",[a._v("jsonp 的原理：jsonp 之所以能跨域，是因为他并不是发送 ajax 请求，并不是利用 XMLHTTPRequest 对象和服务器进行通信，"),s("strong",[a._v("他其实是利用动态创建的"),s("code",[a._v("script")]),a._v("标签，而 script 标签是没有同源策略限制的，可以跨域。")])]),a._v(" "),s("h2",{attrs:{id:"具体方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#具体方法"}},[a._v("#")]),a._v(" 具体方法")]),a._v(" "),s("p",[a._v("创建 script 标签，然后将其 src 指向真实服务端的地址，在这个地址后面有一个参数比如"),s("code",[a._v("callback=a")]),a._v("，然后服务端就可以解析这个 URL 中的 callback=a，在服务端返回数据时，就会调用 a 方法去包裹一段数据，然后返回这段 js 代码，相当于在前端去执行这个 a 方法。在前端发送请求之前，要在 window 上去注册这个 a 方法，那么在服务商返回这个 a 方法执行的时候，就可以去之前 window 上定义的 a 方法中获得数据了。")])])}),[],!1,null,null,null);t.default=e.exports}}]);