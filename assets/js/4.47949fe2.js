(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{393:function(_,e,v){_.exports=v.p+"assets/img/MPT_Trie.a4f939ce.png"},394:function(_,e,v){_.exports=v.p+"assets/img/MPT_Radix_Tree.f93eb3cd.png"},395:function(_,e,v){_.exports=v.p+"assets/img/MPT_Radix_Tree_ep.628deb6c.png"},396:function(_,e,v){_.exports=v.p+"assets/img/MPT_Merkel_Tree.bbcbb33b.png"},397:function(_,e,v){_.exports=v.p+"assets/img/MPT_Merkel_Tree_02.b359e935.png"},398:function(_,e,v){_.exports=v.p+"assets/img/MPT_01.ff294c85.png"},399:function(_,e,v){_.exports=v.p+"assets/img/MPT_Block_header.f738a10e.png"},400:function(_,e,v){_.exports=v.p+"assets/img/MPT_State_trie.e010d426.png"},635:function(_,e,v){"use strict";v.r(e);var t=v(44),a=Object(t.a)({},(function(){var _=this,e=_.$createElement,t=_._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"mpt-merkel-patricia-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mpt-merkel-patricia-tree"}},[_._v("#")]),_._v(" MPT Merkel-Patricia Tree")]),_._v(" "),t("p",[_._v("梅克尔-帕特里夏树")]),_._v(" "),t("h2",{attrs:{id:"什么是-mpt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mpt"}},[_._v("#")]),_._v(" 什么是 MPT")]),_._v(" "),t("ul",[t("li",[_._v("Merker Patricia Tree(MPT)，翻译为梅克尔-帕特里夏树")]),_._v(" "),t("li",[_._v("MPT 提供了一个基于密码学验证的底层数据结构，用来存储键值对（key-value）关系")]),_._v(" "),t("li",[_._v("MPT 是完全确定性的，这是指在一颗 MPT 上一组键值对 是唯一确定的 。相同内容的键可以保证找到相同的值，并且有同样的根哈希（root hash）")]),_._v(" "),t("li",[_._v("MPT 的插入、查找、删除操作的时间复杂度都是"),t("code",[_._v("O(log(n))")]),_._v("，相对于其他基于复杂比较的树结构（比如红黑树），MPT 更容易理解，也更易于编码的实现")])]),_._v(" "),t("h3",{attrs:{id:"从字典树-trie-说起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从字典树-trie-说起"}},[_._v("#")]),_._v(" 从字典树（Trie）说起")]),_._v(" "),t("ul",[t("li",[_._v("字典树（Trie）也称前缀树（prefix tree），属于搜索树，是一种 有序的树数据结构")]),_._v(" "),t("li",[_._v("字典树用于存储动态的集合或映射，其中的键通常是字符串\n"),t("img",{attrs:{src:v(393),alt:"MPT_Trie"}})])]),_._v(" "),t("h3",{attrs:{id:"基数树-radix-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基数树-radix-tree"}},[_._v("#")]),_._v(" 基数树（Radix Tree）")]),_._v(" "),t("ul",[t("li",[_._v("基数树 又叫压缩 前缀树（companct prefix tree），是一种空间优化后的字典树，其中如果一个节点只有唯一的子节点，那么这个子节点就会与父节点合并存储\n"),t("img",{attrs:{src:v(394),alt:"MPT_Radix_Tree.png"}})])]),_._v(" "),t("h4",{attrs:{id:"基数树节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基数树节点"}},[_._v("#")]),_._v(" 基数树节点")]),_._v(" "),t("p",[_._v("在一个标准的基数树里，每个节点存储的数据如下：\n"),t("code",[_._v("[i0,i1,...,in,value]")])]),_._v(" "),t("ul",[t("li",[_._v("这里的 i0,i1,...,in 表示定义好的字母表中的字符，字母表中共有 n+1 个字符，这课树的基数（radix）就是 n+1")]),_._v(" "),t("li",[_._v("value 表示这个字节中最终存储的值")]),_._v(" "),t("li",[_._v("每一个 i0 到 in 的“槽位”，存储的或者是 null，或者说是指向另一个节点的指针")]),_._v(" "),t("li",[_._v("用节点的访问路径表示 key,用节点的最末位存储 value，这就实现了一个基本的键值存储")])]),_._v(" "),t("h4",{attrs:{id:"例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[_._v("#")]),_._v(" 例子")]),_._v(" "),t("ul",[t("li",[_._v("我们有一个键值对"),t("code",[_._v('{"dog":"puppy"}')]),_._v("，现在希望通过键 dog 访问它的值；我们采用 16 进制的 Hex 字符作为字符集")]),_._v(" "),t("li",[_._v("首先我们将“dog”转换为 ASCII 码，这样就得到了字符集中的表示 64 6f67，这就是树结构中对应的键")]),_._v(" "),t("li",[_._v("按照键的字母序，即"),t("code",[_._v("6->4->6->f->6->7")]),_._v("，构建树中的访问路径")]),_._v(" "),t("li",[_._v("从树的跟节点（root）出发，首先读取索引值（index）为 6 的插槽中存储的值，以它为键访问到对应的子节点")]),_._v(" "),t("li",[_._v("然后取出子节点索引值为 4 的插槽中的值，以它为键访问下一层节点，直到访问完所需要的路径")]),_._v(" "),t("li",[_._v('最终访问的叶子节点，就存储了我们想要查找的值，即"puppy"\n'),t("img",{attrs:{src:v(395),alt:"MPT_Radix_Tree_ep.png"}})])]),_._v(" "),t("h4",{attrs:{id:"基数树的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基数树的问题"}},[_._v("#")]),_._v(" 基数树的问题")]),_._v(" "),t("p",[t("strong",[_._v("数据校验")])]),_._v(" "),t("ul",[t("li",[_._v("基数树节点之间的连接方式是指针，一般是用 32 位或 64 位的内存地址作为指针的值，比如 C 语言就是这么做的。但这种直接存地址的方式无法提供对数据内容的校验，而这在区块链这样的分布式系统中非常重要。\n"),t("strong",[_._v("访问效率")])]),_._v(" "),t("li",[_._v("基数树的另一个问题是低效。如果我们只想存一个 bytes32 类型的键值对，访问路径长度就是 64（在以太坊定义的 Hex 字符集吓）；每一级访问的节点都至少需要存储 16 个节点，这样就需要至少 1k 字节的额外空间，而且每次查找和删除都必须完整地执行 64 次下探访问。")])]),_._v(" "),t("h3",{attrs:{id:"梅克尔树-merkel-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#梅克尔树-merkel-tree"}},[_._v("#")]),_._v(" 梅克尔树（Merkel Tree）")]),_._v(" "),t("ul",[t("li",[_._v("也被称为哈希树（Hash Tree），以数据块的 hash 值作为叶子节点存储值。梅克尔树的非叶子节点存储其子节点内容串联拼接后的 hash 值。\n"),t("img",{attrs:{src:v(396),alt:"MPT_Merkel_Tree.png"}})])]),_._v(" "),t("h3",{attrs:{id:"帕特里夏树-patricia-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#帕特里夏树-patricia-tree"}},[_._v("#")]),_._v(" 帕特里夏树（Patricia Tree）")]),_._v(" "),t("ul",[t("li",[_._v("如果一个基数树的“基数”（radix）为 2 或 2 的整数次幂，就被称为“帕特里夏树”，有时也直接认为帕特里夏树就是基数树")]),_._v(" "),t("li",[_._v("以太坊中采用 Hex 字符作为 key 的字符集，也就是基数为 16 的帕特里夏树")]),_._v(" "),t("li",[_._v("以太坊中的树结构，每个节点可以有最多 16 个子节点，在加上 value，所以共有 17 个“插槽”（slot）位置")]),_._v(" "),t("li",[_._v("以太坊中的帕特里夏树加入了一些额外的数据结构，主要是为了解决效率问题")])]),_._v(" "),t("h3",{attrs:{id:"mpt-merkel-patricia-tree-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mpt-merkel-patricia-tree-2"}},[_._v("#")]),_._v(" MPT(Merkel Patricia Tree)")]),_._v(" "),t("ul",[t("li",[_._v("梅克尔-帕特里夏树是梅克尔和帕特里夏树的结合")]),_._v(" "),t("li",[_._v("以太坊中的实现，对 key 采用 Hex 编码，每个 Hex 字符就是一个 nibble（半字节）")]),_._v(" "),t("li",[_._v("遍历路径时对一个节点只访问它的一个 nibble，大多数节点是一个包含 17 个元素的数组；其中 16 个分别以 hex 字符作为索引值，存储路径中下一个 nibble 的指针；另一个存储如果 路径到此已遍历结束，需要返回的最终值。这样的节点叫做“分支节点”（branch node）")]),_._v(" "),t("li",[_._v("分支节点的每个元素存储的是指向下一级节点的指针。与传统做法不同，MPT 是用所指向节点的 hash 来代表这个指针的；每个节点将下个节点的 hash 作为自己存储内容的一部分，这样就实现了 Merkel 树结构，保证了数据校验的有效性")])]),_._v(" "),t("h3",{attrs:{id:"mpt-节点分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mpt-节点分类"}},[_._v("#")]),_._v(" MPT 节点分类")]),_._v(" "),t("p",[t("strong",[_._v("MPT 中的节点有以下几类")])]),_._v(" "),t("ul",[t("li",[_._v("空节点（null）：表示空字符串")]),_._v(" "),t("li",[_._v("分支节点（branch）： 17 个元素的节点，结构为"),t("code",[_._v("[v0, .... v15,vt]")])]),_._v(" "),t("li",[_._v("叶子节点（leaf）：拥有两个元素，编码路径"),t("code",[_._v("encodedPath")]),_._v("和值"),t("code",[_._v("value")])]),_._v(" "),t("li",[_._v("扩展节点（extension）：拥有两个元素，编码路径 encodedPath 和键 key")])]),_._v(" "),t("h3",{attrs:{id:"mpt-中数据结构的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mpt-中数据结构的优化"}},[_._v("#")]),_._v(" MPT 中数据结构的优化")]),_._v(" "),t("ul",[t("li",[_._v("对于 64 个字符的路径长度，很有可能在某个节点处会发现，下面至少有 一段路径没有分叉；而这很难避免")]),_._v(" "),t("li",[_._v("我们 当然可以依然用标准的分支节点来表示，强制要求这个节点必须有完整的 16 个索引，并给没有用到的那 15 个位置全部赋值为空值；但这样有点蠢")]),_._v(" "),t("li",[_._v("通过设置“扩展节点”，就可以有效地缩短访问 路径，将冗长的层级关系压缩成一个键值对，避免不必要的空间浪费")]),_._v(" "),t("li",[_._v("扩展节点（extension node）的内容形式是"),t("code",[_._v("[encodedPath, key]")]),_._v("其中 encodedPath 包含下面不分叉的那部分路径，key 是指向 下一个节点的指针（hash，即在底层 db 中 的存储位置）")]),_._v(" "),t("li",[_._v("叶子节点（leaf node）： 如果在某个节点后就没有了分叉路径，那这是一个叶子节点，它的第二个元素就是自己的 value\n"),t("img",{attrs:{src:v(397),alt:"压缩后的dog路径"}})])]),_._v(" "),t("h3",{attrs:{id:"紧凑编码-compact-coding"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#紧凑编码-compact-coding"}},[_._v("#")]),_._v(" 紧凑编码（compact coding）")]),_._v(" "),t("ul",[t("li",[_._v("路径压缩的处理相当于实现了压缩前缀树的功能；不过路径表示的是 hex 字符串（nibbles），而存储却是以字节（byte）为单位的，相当于 浪费了一倍的存储空间")]),_._v(" "),t("li",[_._v("我们可以采用一种紧凑编码（compact coding）方式，将两个 nibble 整合在一个字节中保存，这就避免了不必要的 浪费")]),_._v(" "),t("li",[_._v("这里就会带来一个问题，可能 nibble 总数是一个奇数，而数据总是以字节形式存储的，所以 无法区分"),t("code",[_._v("nibble 1")]),_._v("和 "),t("code",[_._v("nibbles 01")]),_._v("；这就使我们必须分别处理奇偶两种情况")]),_._v(" "),t("li",[_._v("为了区分路径长度的奇偶性，我们在 encodedPath 中引入标识位")])]),_._v(" "),t("h3",{attrs:{id:"hex-序列的压缩编码规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hex-序列的压缩编码规则"}},[_._v("#")]),_._v(" Hex 序列的压缩编码规则")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("我们在 encodedPath 中，加入一个 nibble 作为前缀，它的后两位用来标识节点类型和路径长度的奇偶性")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Hex 字符")]),_._v(" "),t("th",[_._v("二进制位(bits)")]),_._v(" "),t("th",[_._v("节点类型")]),_._v(" "),t("th",[_._v("路径长度")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("0")]),_._v(" "),t("td",[_._v("0000")]),_._v(" "),t("td",[_._v("扩展")]),_._v(" "),t("td",[_._v("偶")])]),_._v(" "),t("tr",[t("td",[_._v("1")]),_._v(" "),t("td",[_._v("0001")]),_._v(" "),t("td",[_._v("扩展")]),_._v(" "),t("td",[_._v("奇")])]),_._v(" "),t("tr",[t("td",[_._v("2")]),_._v(" "),t("td",[_._v("0010")]),_._v(" "),t("td",[_._v("叶子")]),_._v(" "),t("td",[_._v("偶")])]),_._v(" "),t("tr",[t("td",[_._v("3")]),_._v(" "),t("td",[_._v("0011")]),_._v(" "),t("td",[_._v("叶子")]),_._v(" "),t("td",[_._v("奇")])])])])]),_._v(" "),t("li",[t("p",[_._v("MPT 中还有一个可选的“结束标识”（用 T 表示），值为 0x10(十进制的 16)，它仅能在路径末尾出现，代表节点是一个最终节点（叶子节点）")])]),_._v(" "),t("li",[t("p",[_._v("如果路径是奇数，就与前缀 nibble 凑成整字节；如果是偶数，则前缀 nibble 后补 0000 构成整字节")])])]),_._v(" "),t("h4",{attrs:{id:"编码实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编码实例"}},[_._v("#")]),_._v(" 编码实例")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("[1,2,3,4,5,...]")]),_._v("不带结果位，奇路径\n"),t("ul",[t("li",[t("code",[_._v("11 23 45")])])])]),_._v(" "),t("li",[t("code",[_._v("[0,1,2,3,4,5,...]")]),_._v("不带结束位，偶路径\n"),t("ul",[t("li",[t("code",[_._v("00 01 23 45")])])])]),_._v(" "),t("li",[t("code",[_._v("[0,f,1,c,b,8,10]")]),_._v("带结束位 T 的偶路径\n"),t("ul",[t("li",[t("code",[_._v("20 0f 1c b8")])])])]),_._v(" "),t("li",[t("code",[_._v("[f,1,c,b,8,10]")]),_._v("带结束位 T 的奇路径\n"),t("ul",[t("li",[t("code",[_._v("3f 1c b8")])])])])]),_._v(" "),t("h4",{attrs:{id:"mpt-树结构示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mpt-树结构示例"}},[_._v("#")]),_._v(" MPT 树结构示例")]),_._v(" "),t("ul",[t("li",[_._v("假设我们要构建一个存储了以下键值对的 MPT 树\n"),t("ul",[t("li",[t("code",[_._v('("do","verb"),("dog","puppy"),("doge","coin"),("horse","stallion")')])])])]),_._v(" "),t("li",[_._v("首先我们会把所有的路径（"),t("code",[_._v("path")]),_._v("）转成 ASCII 码表示的"),t("code",[_._v("bytes")]),_._v("：\n"),t("ul",[t("li",[t("code",[_._v("<64 6f>")]),_._v(": "),t("code",[_._v("verb")])]),_._v(" "),t("li",[t("code",[_._v("<64 6f 67>")]),_._v(": "),t("code",[_._v("puppy")])]),_._v(" "),t("li",[t("code",[_._v("<64 6f 67 65>")]),_._v(": "),t("code",[_._v("coin")])]),_._v(" "),t("li",[t("code",[_._v("<64 6f 72 73 65>")]),_._v(": "),t("code",[_._v("stallion")])])])]),_._v(" "),t("li",[_._v("然后我们就可以用在底层 db 中存储的以下键值对，构建出 MPT 树\n"),t("ul",[t("li",[t("code",[_._v("rootHash")]),_._v(": "),t("code",[_._v("[<16>, hashA]")])]),_._v(" "),t("li",[t("code",[_._v("hashA")]),_._v(": "),t("code",[_._v("[<>,<>,<>,<>,hashB,<>,<>,<>,hashC,<>, <>, <>, <>, <>, <>, <>, <> ]")])]),_._v(" "),t("li",[t("code",[_._v("hashC")]),_._v(": "),t("code",[_._v('[<20 6f 72, 73, 65>, "stallion"]')])]),_._v(" "),t("li",[t("code",[_._v("hashB")]),_._v(": "),t("code",[_._v("[<00 6f>, hashD]")])]),_._v(" "),t("li",[t("code",[_._v("hashD")]),_._v(": "),t("code",[_._v('[<>,<>,<>,<>,<>,<>,hashE, <>, <>, <>, <>, <>, <>, <>, <>, <>,"verb"]')])]),_._v(" "),t("li",[t("code",[_._v("hashE")]),_._v(": "),t("code",[_._v("[<17>, hashF]")])]),_._v(" "),t("li",[t("code",[_._v("hashF")]),_._v(": "),t("code",[_._v("[<>,<>,<>,<>,<>,<>,hashG, <>, <>, <>, <>, <>, <>, <>, <>, <>, 'puppy']")])]),_._v(" "),t("li",[t("code",[_._v("hashG")]),_._v(": "),t("code",[_._v('[<35>, "coin"]')])])])])]),_._v(" "),t("p",[t("img",{attrs:{src:v(398),alt:"MPT_01.png"}})]),_._v(" "),t("h3",{attrs:{id:"以太坊中树结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#以太坊中树结构"}},[_._v("#")]),_._v(" 以太坊中树结构")]),_._v(" "),t("ul",[t("li",[_._v("以太坊中所有的 merkel 树都是 MPT")]),_._v(" "),t("li",[_._v("在一个区块的头部（block head）中，有三个 MPT 树根：\n"),t("ul",[t("li",[_._v("stateRoot: 状态树的树根")]),_._v(" "),t("li",[_._v("transactionRoot: 交易树的树根")]),_._v(" "),t("li",[_._v("receiptsRoot: 收据树的树根")])])])]),_._v(" "),t("p",[t("img",{attrs:{src:v(399),alt:"MPT_Block_header.png"}})]),_._v(" "),t("h3",{attrs:{id:"以太坊中树结构-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#以太坊中树结构-2"}},[_._v("#")]),_._v(" 以太坊中树结构")]),_._v(" "),t("ul",[t("li",[_._v("状态数(state trie)\n"),t("ul",[t("li",[_._v("世界状态数，随时更新；它存储的键值对（path, value）可以表示为"),t("code",[_._v("(sha3(ethereumAddress), rlp(ethereumAccount))")])]),_._v(" "),t("li",[_._v("这里的 account 是 4 个元素构成的数组: "),t("code",[_._v("[nonce, balance,storageRoot,codeHash]")])])])]),_._v(" "),t("li",[_._v("存储树(storage trie)\n"),t("ul",[t("li",[_._v("存储树是保存所有合约数据的地方；每个合约账户都有一个独立隔离的存储空间")])])]),_._v(" "),t("li",[_._v("交易树（transaction trie）\n"),t("ul",[t("li",[_._v("每个区块都会有单独的交易数，他的路径（path）是 rlp(transactionIndex)，只有在挖矿时才能确定；一旦 出块，不再更改")])])]),_._v(" "),t("li",[_._v("收据树（receipts trie）\n"),t("ul",[t("li",[_._v("每个区块也有自己的收据树；路径也表示为 rlp(transactionIndex)\n"),t("img",{attrs:{src:v(400),alt:"MPT_State_trie.png"}})])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);